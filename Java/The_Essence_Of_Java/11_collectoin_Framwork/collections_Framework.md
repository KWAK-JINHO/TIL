# 컬렉션 프레임웍

- 데이터군을 저장하는 클래스들을 표준화한 설계를 컬렉션 프레임워크라고 한다.

### 핵심 인터페이스

- 3개의 인터페이스로 정의 List, Set, Map
- 여기서 List와 Set은 공통부분이 많아서 Collection으로 한번 더 합쳤다.
- List는 순서o 중복o, Set은 순서x, 중복x, Map은 순서x, 중복은 value만 허용한다.

### collection 인터페이스

- 가장 기본적인 읽고, 추가, 삭제등을 다룬다.

### List 인터페이스

- 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현할 때 사용.

### Set 인터페이스

- 중복을 허용하지 않고, 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용.
- 메서드가 collection 인터페이스의 메서드 + 집합관련 메서드(합집합, 부분집합, 차집합, 교집합) - boolean값으로 반환된다.
- HashSet은 대용량, TreeSet은 범위검색, 정렬

### Map인터페이스

- 키와 값을 하나의 싸으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용.
- 동기화처리의 차이로 HashMap 과 Hashtable를 나눈다

### Map.Entry 인터페이스

- Map인터페이스의 내부인터페이스
- Key와 value쌍을 다루기 위해서 내부적으로 정의해놓음

### ArrayList

- 기존의 Vector를 개선한 것
- Object배열을 이용해서 데이터를 순차적으로 저장한다.

#### remove()

- 구현방식
    - 지정된 위치에 있는 데이터 바로 아래에 데이터를 한칸씩 위로 덮어써서 삭제. 마지막 데이터는 null로 변경
    - 만약 마지막 데이터 삭제면 단순히 null로 변경

- 첫번째부터 삭제할때
  ```
  for(int i = 0; i < list.size(); i++)
      list.remove(i);
  ```
    - 배열 복사가 발생한다.

- 뒤부터 삭제할 때
  ```
  for(int i = list.size() - 1; i >= 0; i--)
      list.remove(i);
  ```
    - 배열복사 발생 안한다.(빠름)

### LinkedList

- 배열의 단점(크기변경 불가, 중간에 데이터의 추가 또는 삭제에 시간이 많이걸림)을 보완하기 위해서 생겨남.

#### 배열의 장단점

- 장점
    - 데이터 접근시간이 빠르다(앞쪽으로 접근, 뒤쪽으로 접근 비슷)
- 단점
    - 크기변경불가(실행중에)
    - 순서대로 안하면 추가/삭제 느리다.

#### LinkedList의 장단점

- 장점
    - 변경에 유리
    - 불연속적
- 단점
    - 접근성이 떨어짐(한칸씩 넘어가야해서) -> 이중연결리스트 고안

#### 데이터의 추가

- 배열은 연속적이다(크기변경이 불가)
- ✴️배열의 크기변경
    1. 더 큰 배열을 생성
    2. 내용복사
    3. 참조를 변경
- LinkedList 크기변경
    - 참조를 변경하기만 하면됨
- ✴️LinkedList의 데이터를 추가하는데 걸리는 시간 줄이는 방법
    1. 끝의 주소를 기억해 끝에 추가
    2. 데이터의 앞에 추가(이동을 줄인다.)

#### ArrayList vs LinkedList

- 읽기 ArrayList가 빠름
- 추가삭제는 LinkedList가 빠르다.

### Arrays

- 배열을 다루는데 유용한 메서드가 정의.

### Comparator와 Comparable

- Comparable: 기본 정렬기준을 구현하는데 사용
    - compareTo메서드를 가지고 있다: 주어진 객체를 this와 비교
- Comparator: 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용
    - compare메서드를 가지고 있다: 주어진 두개의 값을 비교

- 둘다 값을 비교해서 양수면 왼쪽값이 크다. 0이면 값이 같다. 음수면 오른쪽이 크다.
- 정렬의 방법이 매우 많지만 결국에 2개를 비교해서 자리를 바꾸는 것은 변하지 않는다. -> 불변
- 때문에 정렬기준(가변)을 변경해서 여러 정렬 방법을 만들어 놓음

### HashSet

- 순서x, 중복x
- set인터페이스 구현
- set은 보통 HashSet을 쓰는데 저장순서를 유지하려면 LinkedHashList 사용하면 된다.
- add메서드를 사용하려고 하면(커스텀 객체) equals()와 hashCode()를 호출하기 때문에 이 둘을 오버라이딩 해줘야 한다. //예제 Ex11_24 확인
- equals와 hashcode는 같이 오버라이딩 하는게 정석이다. hash가 붙은 클래스들은 hash코드를 내부적으로 자주사용하기 때문에.
- return (name+age).hashCode() -> return objects.hash(name+age) 최신에는 이렇게 쓴다.

### TreeSet

- 순서o, 중복x
- 정렬순서는 o, 저장순서는 x
- 편향트리를 방지하기 위해서 내부에 레드-블랙트리를 사용해 구현했다.
- 이진탐색트리 구조로 데이터 저장
- 범위검색과 정렬에 유리하다.
- HashSet보다 데이터 추가,삭제에 시간이 더 걸린다.

### 이진탐색트리

- 부모보다 작으면 왼쪽, 크면 오른쪽
- 범위검색 매우 빠르다
- 순차적이지 앚ㅎ아서 추가/삭제 오래 걸린다.

### HashMap

- 순서x, 중복(key X, vaule O)
- 동기화x
- 순서필요하면 linkedHasMap사용
- 해싱 기법으로 데이터 저장, 검색 빠르다(데이터가 커도)
- Entry[]에 저장

### 해싱

- 해쉬함수를 이요해서 hash table의 데이터를 저장하고 읽어 오는 것
- 같은 key를 넣으면 항상 같은 HashCode 나온다. -> 자징 & 읽기 같은 값이 나와야 한다.
    - 서로 다른 key여도 같은 hashcode 반환 가능.
- Hash Table: Array(접근성) + LinkedList(변경유리)
- Hash Function: table, HashMap, HashSet => Objects.hash()사용해서 작성

### TreeMap

- key, value로 저장되는 것 빼면 TreeSet 과 똑같다

### Collections

- collection 관련 메서드 제공