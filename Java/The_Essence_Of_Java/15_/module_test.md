# 자바의 정석 모듈테스트

# 객체지향 개념의 4대 핵심개념

1. 캡슐화 - 데이터와 메서드를 하나로 묶고 외부에서의 접근을 제어하고 보호하는 것
2. 상속 - 기존 클래스를 확장해서 새로운 클래스를 작성하는 것
3. 추상화 - 공통점을 뽑아내는 것
4. 다형성 - 같은 이름의 메서드가 다른 기능을 수행할 수 있게 하는 것

# 오버로딩의 조건 3가지

1. 메서드의 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야한다.
3. 반환타입을 다르게 하는건 영향이 없다.

# 오버라이딩의 조건

1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
2. 접근제어자를 부모 클래스보다 더 넓게는 가능하지만 좁게는 설정할 수 없다.
3. 부모 클래스보다 더 많은 예외를 던질 수 없다.

# 생성자 조건 4가지

1. 클래스와 동일한 이름을 사용
2. 반환타입이 없음(void 안쓴다)
3. 다른 생성자 호출은 반드시 첫줄에서 해야한다.
4. 다른 생성자 호출시 this()사용
5. 객체를 생성할 때 new키워드와 함께 사용

# 다형성 장점 2가지

1. 매개변수의 다형성
2. 하나의 배열에서 여러 종류의 객체를 저장할 수 있다.

# 추상화에 대해서 아는 대로 기술

1. 불필요한 세부 사항을 제거하고 공통적인 것을 뽑아내는 것
2. 복잡도를 감소시키고 재사용성을 증가 시키면 유지보수가 용이해진다

# 불변 (immutable)에 대해서 아는대로 기술

1. 생성 후 객체의 상태가 변하지 않는 것, 객체가 가지는 값 수정 불가능.
2. 함수형 프로그래밍의 핵심개념으로 객체의 상태관리를 단순화시킨다.
3. Stinrg클래스 , Wrapper클래스, 날짜관련 클래스가 불변이다.

# 추상클래스와 인터페이스의 차이

1. 인터페이스
    - 모든 메서드가 추상메서드
    - 오직 public static fianl 변수만 가질 수 있다.(상수)
    - 생성자를 가질 수 없다.
    - 다중 구현 가능
    - 서로 관련성이 없는 클래스들이 공통적으로 사용하는 방식을 정의한다.

2. 추상클래스
    - 추상 메서드와 일반 메서드 모두 가질 수 있다.
    - 모든 종류의 변수를 가진다.
    - 생성자를 가질 수 있다.
    - 단일 상속만 가능
    - 관련된 클래스들의 공통 기능을 추상화

# Object 클래스는 iv가 하나도 없는데, 인스턴스 메서드를 가지는 이유

1. 최고조상으로서 11개의 메서드만 가지고 있는데 이 메서드들은 모든 인스턴스가 가져야 할 기본적인 것들로서 메서드를 호출하면 자동으로 인스턴스 자신을 전달받기 때문에

# 컬렉션 프레임 워크의 핵심 인터페이스 3개를 적고 각 특징 적으시오.

1. list
    - 순서 o, 중복 o
2. set
    - 순서 x, 중복 x
3. map
    - 순서 x, 중복 - key x, value o
    - key - vlaue 쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 놓았다.

# 클래스 변수와 인스턴스 변수의 초기화의 순서와 과정에 대해서 설명

1. 클래스 변수들이 가장 먼저 메모리에 생성되고 모든 인스턴스가 그 값을 공유한다.
2. new() 메서드로 인스턴스가 생성되면 인스턴스 변수들을 초기화하고 각 인스턴스별로 독립된 메모리공간에 저장된다.

# 예외처리 방법에 4가지 설명

1. try-catch: 직접처리
2. 예외선언하기: 예외를 호출한 사람에게 떠넘기기
3. 은폐: 빈 catch블럭을 사용
4. 예외 되던지기: 호출한 메서드와 호출된 메서드 양쪽에서 예외처리하기

# 연결된 예외의 장점 2가지에 설명

1. 예외 A가 예외 B를 발생시키면 A는 B의 원인 예외, A와 B를 연결하는 것을 의미
2. 장점1. 여러 예외를 하나로 묶어서 다룰 수 있다.
3. 장점2. checked예외 -> unchecked 예외로 변경

# 오류의 종류 3개 설명

1. 컴파일 에러: 컴파일 시에 발생하는 에러
2. 런타임 에러: 실행 시에 발생하는 에러
3. 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것

# 인터페이스의 장점에 대해서 아는 대로 적기

1. 변경에 유리한 설계 가능
2. 선언과 구현을 분리할 수 있음
3. 표준화가 가능하다
4. 서로 관계없는 클래스들을 맺어줄 수 있음

# 얕은 복사와 깊은 복사에 대해 아는 대로 적기

1. clone()으로 복제하는 경우 원본과 복제본이 같은 객체를 공유하므로 완전한 복제라고 보기 어렵고 이를 얕은복사라고 한다.
2. 원본과 복사본이 서로 다른 객체를 참조하여 원본의 변경이 복사본에 영향을 끼치지 않는것을 깊은 복사라고 한다.

# 접근 제어자 4개를 넓은 범위 부터 순서대로 적고 각 접근 범위를 적기

1. public(제한없음): 같은 클래스 + 같은패키지 + 자손클래스 + 전체
2. protected: 같은 클래스 + 같은패키지 + 자손클래스
3. default: 같은 클래스 + 같은패키지
4. private: 같은 클래스

# 제어자 final이 붙을 수 있는 모든 대상의 종류를 적고, 각 경우의 의미

1. 클래스: 변경, 확장 불가능한 클래스. 상속계층도의 제일 마지막(자손없는 클래스)
2. 변수(iv, lv): 상수
3. 메서드: 오버라이딩이 불가능한 메서드(변경될 수 없는)

# 객체지향 개념을 프로그래밍에 도입하게 된 가장 큰 이유

1. 재사용성을 높이고 유지보수를 용이하게 하기 위해서.
2. 객체 단위로 코드를 모듈화하면 수정하기가 쉽기 때문.

# Class 객체에 대해서 아는대로 적기

1. 클래스의 모든 정보를 담고 있으며, 클래스당 단 1개만 존재한다.
2. 클래스 파일(설계도)을 읽어서 사용하기 편한 형태로 저장해 놓은 것

# HashMap의 해시함수가 동작하는 방식에 대해서 설명

1. 검색하고자 하는 값의 키로 해시함수를 호출
2. 해시함수의 해시코드로 해당 값이 저장되어 있는 링크드 리스트를 찾는다.
3. 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다.

# comparator와 comparable의 차이

1. comparable 기본 정렬기준을 구현하는데 사용. 주어진 객체를 this와 비교
2. comparator 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용

# properties 설명

1. Hashtable을 상속받아 구현한 것으로, (String, String) 의 형태로 저장하는 단순화된 클래스
2. 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공

# 지네릭스와 와일드 카드가 무엇이며 왜 사용하는지 적기

1. 지네릭스: 다향한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능. 의도치 않은 타입의 객체가 저장되는 것을 막고, 잘못된 형변환의 번거로움을 줄이기 위해서 사용
2. 와일드 카드: 지네릭 타입의 사용시 타입을 대신하는 것으로, 어떤 타입도 될 수 있다는 의미. 하나의 참조변수로 서로 다른 타입이 대입된 여러 지네릭 객체를 다루기 위한 것

# 클래스에 사용된 지네릭 타입 T가 있을 때 클래스 내에서 T를 사용할 수 없는 경우

1. static멤버에 사용 불가. T는 인스턴스 변수로 간주되기 때문

# 자바에서 제공하는 표준 애너테이션(메타 애너테이션 포함)을 아는대로 적고 간단히 설명

1. 표준
    - @Override - 오버라이딩 컴파일러가 체크
    - @Deprecated - 사용하지 않을 것을 권장
    - @FunctionalInterface - 함수형 인터페이스 옳바르게 작성했는지 체크
    - @SuppressWarnings - 컴파일러의 경고 메시지가 나타나지 않게
2. 메타
    - @Target - 애너테이션 적용 가능
    - @Documented - javadoc으로 작성된 문서에 포함되게한다
    - @Inherited - 자손 클래스에 상속되도록
    - @Retention - 애너테이션이 유지되는 범위를 지정
    - @Repeatable - 애너테이션을 반복해서 적용할 수 있게 한다.

# 프로세스와 쓰레드에 대해서 아는대로 쓰기

1. 프로그램: 실행 가능한 파일
2. 프로세스(공장): 프로그램을 실행하면 os로부터 실행에 필요한 자원(메모리, cpu)를 할당받아 프로세스가 된다.
3. 쓰레드(일꾼): 프로세스 내에서 실제 작업을 수행. 모든 프로세스는 최소 하나의 쓰레드를 가진다.

# 쓰레드를 제어하는 메서드 7개를 모두 쓰고 설명

1. sleep(): 일정시간동안 쓰레드 멈추게 함
2. interrupt(): 쓰레드의 작업을 취소한다.
3. suspend(): 일시정시, 교착상태를 일으키기 쉽기 때문에 deprecated 됨
4. resume(); 재개, 교착상태를 일으키기 쉽기 때문에 deprecated 됨
5. stop(): 완전정지, 교착상태를 일으키기 쉽기 때문에 deprecated 됨
6. yield(): 다른 쓰레드에게 양보
7. join(): 다른 쓰레드의 작업을 기다림

# 락lock의 종류3가지를 적고 설명

1. ReentrantLock: 재진입이 가능한 lock, 가장 일반적인 베타 lock
2. ReentrantReadWriteLock: 읽기에는 공유적, 쓰기에는 베타적인 lock
3. StampedLock: ReentrantReadWriteLock에 낙관적인 읽기 lock기능