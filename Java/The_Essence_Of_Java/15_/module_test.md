# 모듈 테스트 11.5 업데이트

1. 객체지향 개념의 4대 핵심개념

- 캡슐화: 데이터와 메서드를 하나로 묶고 외부에서의 접근을 제어하고 보호하는 것
- 상속: 기존 클래스를 확장해서 새로운 클래스를 작성하는 것
- 추상화: 공통점을 뽑아내는 것
- 다형성: 조상 클래스의 참조 변수로 자손 인스턴스를 참조하는 것

2. 오버로딩의 조건 3가지

- 메서드의 이름이 같아야 한다
- 매개변수의 개수 또는 타입이 달라야 한다
- 반환타입을 다르게 하는 것은 영향이 없다

3. 오버라이딩의 조건

- 선언부가 조상 클래스의 메서드와 일치해야 한다
- 접근제어자를 부모 클래스보다 더 넓게는 가능하지만 좁게는 설정할 수 없다
- 부모 클래스보다 더 많은 예외를 던질 수 없다

4. 생성자 조건 4가지

- 클래스와 동일한 이름을 사용
- 반환타입이 없음 (void 안 쓴다)
- 다른 생성자 호출은 반드시 첫 줄에서 해야 한다
- 다른 생성자 호출 시 this() 사용

5. 다형성 장점 2가지

- 매개변수의 다형성
- 하나의 배열에서 여러 종류의 객체를 저장할 수 있다

6. 추상화에 대해서 아는 대로 기술

- 불필요한 세부 사항을 제거하고 공통적인 것을 뽑아내는 것
- 복잡도를 감소시키고 재사용성을 증가, 유지보수가 용이

7. 불변 (immutable)에 대해서 아는 대로 기술

- 변하지 않는 것을 의미
- 대표적으로 String 클래스가 있다. String 클래스의 경우 리터럴 생성 방식과 인스턴스 생성 방식(new)에 따라 차이가 있지만, 한 번 생성된 String 객체는 변하지 않는다.
    - String str = "abc"
    - str = "def"
    - 이 코드는 str에 값을 변경(덮어쓰기)하는 것처럼 보이지만, 내부적으로는 한 번 생성된 "abc" 객체는 변하지 않고 새로운 "def" 객체가 생성되는 것이다.

8. 추상클래스와 인터페이스의 차이

- 인터페이스
    - 모든 메서드가 추상메서드
    - 오직 public static final 변수만 가질 수 있다 (상수)
    - 생성자를 가질 수 없다
    - 다중 구현 가능
    - 서로 관련성이 없는 클래스들이 공통적으로 사용하는 방식을 정의한다
- 추상클래스
    - 추상 메서드와 일반 메서드 모두 가질 수 있다
    - 모든 종류의 변수를 가진다
    - 생성자를 가질 수 있다
    - 단일 상속만 가능
    - 관련된 클래스들의 공통 기능을 추상화

9. Object 클래스는 iv가 하나도 없는데, 인스턴스 메서드를 가지는 이유

- Object 클래스는 모든 클래스의 최고 조상이기 때문에 여러 클래스가 오버라이딩해서 사용하는 공통적인 인스턴스 메서드를 가지고 있다. 자손 클래스들은 인스턴스 메서드를 오버라이딩해서 자손 클래스의 iv로 각
  클래스의 용도에 맞게 재정의하여 사용한다.

10. 컬렉션 프레임워크의 핵심 인터페이스 3개를 적고 각 특징 적으시오.

- List
    - 순서 O, 중복 O
    - 구현클래스: ArrayList, LinkedList
- Set
    - 순서 X, 중복 X
    - 구현클래스: HashSet, TreeSet
- Map
    - 순서 X, 중복 - key X, value O
    - key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다
    - 구현클래스: HashMap, TreeMap

11. 클래스 변수와 인스턴스 변수의 초기화의 순서와 과정에 대해서 설명

- 클래스 변수(cv)가 인스턴스 변수(iv)보다 먼저 초기화된다. cv는 객체 생성이 필요 없기 때문에
- 자동 -> 간단(명시) -> 복잡
- 명시적 초기화는 =를 사용한 초기화, 복잡 {}, static {}, 생성자를 이용한 초기화

12. 예외처리 방법 4가지 설명

- try-catch: 직접 처리
- 예외 선언하기: 예외를 호출한 사람에게 떠넘기기
- 은폐: 빈 catch 블록을 사용
- 예외 되던지기: 호출한 메서드와 호출된 메서드 양쪽에서 예외처리하기

13. 연결된 예외의 장점 2가지 설명

- 예외 A가 예외 B를 발생시키면 A는 B의 원인 예외, A와 B를 연결하는 것을 의미
- 장점 1: 여러 예외를 하나로 묶어서 다룰 수 있다
- 장점 2: checked 예외 -> unchecked 예외로 변경

14. 오류의 종류 3개 설명

- 컴파일 에러: 컴파일 시에 발생하는 에러
- 런타임 에러: 실행 시에 발생하는 에러
- 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것

15. 인터페이스의 장점에 대해서 아는 대로 적기

- 변경에 유리한 설계 가능
    - 선언과 구현을 분리할 수 있음
    - 표준화가 가능하다
    - 서로 관계없는 클래스들을 맺어줄 수 있음

16. 얕은 복사와 깊은 복사에 대해 아는 대로 적기

- clone()으로 복제하는 경우 원본과 복제본이 같은 객체를 공유하므로 완전한 복제라고 보기 어렵고 이를 얕은 복사라고 한다.
- 원본과 복사본이 서로 다른 객체를 참조하여 원본의 변경이 복사본에 영향을 끼치지 않는 것을 깊은 복사라고 한다.

17. 접근 제어자 4개를 넓은 범위부터 순서대로 적고 각 접근 범위를 적기

- public (제한 없음): 같은 클래스 + 같은 패키지 + 자손 클래스 + 전체
- protected: 같은 클래스 + 같은 패키지 + 자손 클래스
- default: 같은 클래스 + 같은 패키지
- private: 같은 클래스

18. 제어자 final이 붙을 수 있는 모든 대상의 종류를 적고, 각 경우의 의미

- 클래스: 변경, 확장 불가능한 클래스. 상속 계층도의 제일 마지막 (자손 없는 클래스)
- 변수 (iv, lv): 상수
- 메서드: 오버라이딩이 불가능한 메서드 (변경될 수 없는)

19. 객체지향 개념을 프로그래밍에 도입하게 된 가장 큰 이유

- 재사용성을 높이고 유지보수를 용이하게 하기 위해서.
- 객체 단위로 코드를 모듈화하면 수정하기가 쉽기 때문.

20. Class 객체에 대해서 아는 대로 적기

- 클래스의 모든 정보를 담고 있으며, 클래스당 단 1개만 존재한다.
- 클래스 파일(설계도)을 읽어서 사용하기 편한 형태로 저장해 놓은 것

21. HashMap의 해시함수가 동작하는 방식에 대해서 설명

- 검색하고자 하는 값의 키로 해시함수를 호출
- 해시함수의 해시코드로 해당 값이 저장되어 있는 링크드 리스트를 찾는다.
- 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다.

22. Comparator와 Comparable의 차이

- Comparable: 기본 정렬 기준을 구현하는 데 사용. 주어진 객체를 this와 비교
- Comparator: 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용

23. Properties 설명

- Hashtable을 상속받아 구현한 것으로, (String, String)의 형태로 저장하는 단순화된 클래스
- 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공

24. 지네릭스와 와일드카드가 무엇이며 왜 사용하는지 적기

- 지네릭스: 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스의 컴파일 시의 타입 체크를 해주는 기능. 의도치 않은 타입의 객체가 저장되는 것을 막고, 잘못된 형변환의 번거로움을 줄이기 위해 사용
- 와일드카드: 지네릭 타입의 사용 시 타입을 대신하는 것으로, 어떤 타입도 될 수 있다는 의미. 하나의 참조 변수로 대입된 타입이 다른 객체를 참조

25. 클래스에 사용된 지네릭 타입 T가 있을 때 클래스 내에서 T를 사용할 수 없는 경우

- static 멤버에 사용 불가. T는 인스턴스 변수로 간주되기 때문

26. 자바에서 제공하는 표준 애너테이션(메타 애너테이션 포함)을 아는 대로 적고 간단히 설명

- 표준 애너테이션
    - @Override: 오버라이딩을 컴파일러가 체크
    - @Deprecated: 사용하지 않을 것을 권장
    - @FunctionalInterface: 함수형 인터페이스가 올바르게 작성되었는지 체크
    - @SuppressWarnings: 컴파일러의 경고 메시지가 나타나지 않게 함
- 메타 애너테이션
    - @Target: 애너테이션 적용 가능 대상 지정
    - @Documented: javadoc으로 작성된 문서에 포함되게 함
    - @Inherited: 자손 클래스에 상속되도록 함
    - @Retention: 애너테이션이 유지되는 범위를 지정
    - @Repeatable: 애너테이션을 반복해서 적용할 수 있게 함

27. 프로세스와 쓰레드에 대해서 아는 대로 쓰기

- 프로그램: 실행 가능한 파일
- 프로세스(공장): 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리, CPU)를 할당받아 프로세스가 된다.
- 쓰레드(일꾼): 프로세스 내에서 실제 작업을 수행. 모든 프로세스는 최소 하나의 쓰레드를 가진다.

28. 쓰레드를 제어하는 메서드 7개를 모두 쓰고 설명

- sleep(): 일정 시간 동안 쓰레드 멈추게 함
- interrupt(): 쓰레드의 작업을 취소한다
- suspend(): 일시 정지, 교착 상태를 일으키기 쉽기 때문에 deprecated 됨
- resume(): 재개, 교착 상태를 일으키기 쉽기 때문에 deprecated 됨
- stop(): 완전 정지, 교착 상태를 일으키기 쉽기 때문에 deprecated 됨
- yield(): 다른 쓰레드에게 양보
- join(): 다른 쓰레드의 작업을 기다림

29. 락 (Lock)의 종류 3가지를 적고 설명

- ReentrantLock: 재진입이 가능한 lock, 가장 일반적인 베타 lock (동시에 한 쓰레드만 리소스에 접근이 가능하게 함)
- ReentrantReadWriteLock: 읽기에는 공유적, 쓰기에는 베타적인 lock
- StampedLock: ReentrantReadWriteLock에 낙관적인 lock 기능을 추가

30. 블로킹이 무엇이며, 언제 발생하는지 설명

- 쓰레드가 입출력 처리를 위해 기다리는 것
- 사용자로부터 입력받는 작업과 화면에 출력하는 작업을 하나의 쓰레드로 처리하면 사용자가 입력을 마칠 때까지 기다려야 한다.
