# 변수

### 컴퓨터(계산기)
    
- 저장
    - 변수: 1개
    - 배열: 0(공집합) ~ n개 //여러개는 무조건 집합이다 -> 집합을 해야 복잡도를 높일 수 있다.
- 계산
    1. 산술: +, -, *, /, %
    2. 비교: >, <, >=, <=, ==
    3. 논리: &&, ||, !
- 반복,조건
    1. for문: 중요한 것은 조건과 횟수
    2. if문

### 설계 -> 그리기, 그룹화, 분류, 관계

- 설계는 그룹핑(디테일하게 묶는 것)
- 설계는 확장성과 유지보수를 높이는데 주요하다.

### 변수

- 하나의 값을 저장공간에 이름 붙인 것 -> 읽기와 쓰기가 전부

```int(타입) age = 5(값);```

- 최근에 와서 타입과 값을 굳이 쓸 필요가 없을경우 "var" 를 사용하게 바뀌었다 -> 타입추론
- 타입추론은 재사용성에 유리

### 값

- 문자(char): 1개 + boolean 논리형 (참:1, 거짓:0)
- 숫자 -> 정수(byte, short, long, int) + 실수(float, double)

- 결국 값은 크게보면 정수와 실수로 나뉜다.
- 정수는 오차가 없고, 실수는 오차가 존재한다.
  - 정수는 메모리 하나에 통으로 값을 통으로 넘기고 실수는 하나에 쪼개서 넣기 때문에 오차가 발생한다.

### 형변환

- 기본형
  - 정수
  - 실수
- 참조형 : 부모 <---> 자식

- 실수의 오차 원인
  1. 원래 오차가 존재한다. -> 루트2의 경우 무한소수이므로 컴퓨터로 나타낼 때 오차 발생
  2. 10진수를 2진수로 변환할 때 -> 컴퓨터는 2진수로 처리되기 때문에 변환할 때 오차 발생한다.
  3. 저장공간의 한계

### 지역변수, 클래스변수, 인스턴스변수

- 예시
```commandline
public class Car {
    // 인스턴스 변수
    String color;
    
    // 클래스 변수 (static)
    static int carCount = 0;
    
    public void paintCar(String newColor) {
        // 지역 변수
        String oldColor = color;
        
        color = newColor;
        carCount++;
        
        System.out.println("Car color changed from " + oldColor + " to " + color);
        System.out.println("Total cars: " + carCount);
    }
}
```

1. 인스턴스변수
  - 인스턴스가 생성될 때 마다(위예시에서는 각 car객체 마다)다른 값을 유지할 수 있다.
  - 라이프사이클
    생성: car객체가 생성될 때 힙 메모리에 할당된다.
    사용: 객체의 메서드에서 사용되거나 외부에서 객체를 통해 접근 가능하다.
    소멸: 가비지컬렉션의 대상이 될때까지 메모리에 존재

2. 클래스변수
  - 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.
  - 라이프사이클
    생성: 프로그램이 실행되고 해당 클래스가 메모리에 로드될 때 생성된다.
    사용: 모든 해당객체에서 공유되며, 클래스 이름을 통해 직접 접근 가능.
    소멸: 프로그램이 종료될 때까지 메모리에 존재한다.

3. 지역변수
  - 메서드내의 변수로 메서드가 실행될때만 존재한다.
  - 라이프사이클
    생성: 메서드가 호출되어 실행을 시작할 때 스텍 메모리에 생성된다.
    사용: 해당 메서드 내에서만 사용 가능
    소멸: 해당 메서드가 종료되면 즉시 스텍에서 제거

### 힙 메모리 vs 스텍 메모리

- Heap
  - 동적으로 할당되는 메모리 영역으로, 객체의 인스턴스가 생성될 때 이 영역에 메모리가 할당된다.
  - 가바지 컬렉터에 의해 관리되며, 더 이상 참조되지 않은 객체는 자동으로 메모리에서 해제.
  - 프로그램 전체에서 공유되는 큰 메모리 풀, 객체의 수명동안 지속된다.
  
- Stack
  - 메서드 호출과 관련된 정보를 저장하는 메모리 영역
  - 메서드가 호출될 때 생성되고 메서드 실행이 끝나면 자동으로 제거
  - 각 스레드마다 별도로 할당되며, 메서드 호출과 함께 빠르게 할당/해제