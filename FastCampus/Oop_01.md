# 객체지향 프로그래밍 1

### 

### this() vs this
this()
생성자

this
참조변수


### 초기화


- 객체의 초기화
```Circle c = new Circle();``` 
- 메모리 흐름
    - 참조변수 선언: 스택 메모리에 Circle타입의 참조변수 c가 생성된다.
    - 객체생성: 힙 메모리에 Circle객체가 생성된다.
    - 참조 할당: 스택의 참조변수 c에 힙에 생성된 Circle객체의 주소가 저장된다.



# 객체지향 프로그래밍2

### 참조변수 super(≈this)

- this는 lv와 iv 를 구별하는데 사용
- super는 부모멤버와 자식멤버을 구별하는데 사용한다. (부모와 자식이 같은이름의 변수를 사용할때 부모는 super. 자식은 this. 으로 구별)
- 같은변수가 없을 때도 super this둘다 사용가능. 둘다 같은 변수를 가르킨다.
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재

### super()

- 부모의 생성자호출할 때 사용
- 부모의 멤보는 부모의 생성자를 호출해서 초기화. 
- 자식은 자식이 선언한 것만 초기화 하는게 좋다.
예시)
```commandline
class Point {
  int x, y;
  
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}

class Point3D extends Point {
  super(x, y); // 부모의 생성자 Point(int x, int y)를 호출
  this.z = z;
}
```

#### super() 조건

- 생성자의 첫 줄에 반드시 다른 생성자를 호출(생성자 체이닝). 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

### 제어자(modifier)

- 하나의 대상에 여러 제어자를  사용가능(접근 제어자는 하나만)

#### 제어자의 종류

- 접근 제어자
    - public
    - protected
    - default
    - private
- 그외
    - static
      - 멤버변수: 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하며 클래스가 메모리에 로드될 때 생성됨.
      - 메서드: static 메서드 에서는 iv, instatnce 메서드 사용불가
    - fianl
      - 클래스: 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
      - 메서드: 변경될 수 없는 메서드. 오버라이딩 사용 불가
      - 멤버변수, 지역변수: 값을 변경할 수 없는 상수
    - abstract
      - 클래스: 구현부가 없는 메서드(선언부만 존재), 인스턴스 생성 불가. 추상클래스를 상속받아서 완전한 클래스를 만든후에 객체생성 가능.
      - 메서드: 선언부만 작성