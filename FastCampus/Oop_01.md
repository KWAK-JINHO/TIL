# 객체지향 프로그래밍 1

### 

### this() vs this
this()
생성자

this
참조변수


### 초기화


- 객체의 초기화
```Circle c = new Circle();``` 
- 메모리 흐름
    - 참조변수 선언: 스택 메모리에 Circle타입의 참조변수 c가 생성된다.
    - 객체생성: 힙 메모리에 Circle객체가 생성된다.
    - 참조 할당: 스택의 참조변수 c에 힙에 생성된 Circle객체의 주소가 저장된다.



# 객체지향 프로그래밍2

### 참조변수 super(≈this)

- this는 lv와 iv 를 구별하는데 사용
- super는 부모멤버와 자식멤버을 구별하는데 사용한다. (부모와 자식이 같은이름의 변수를 사용할때 부모는 super. 자식은 this. 으로 구별)
- 같은변수가 없을 때도 super this둘다 사용가능. 둘다 같은 변수를 가르킨다.
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재

### super()

- 부모의 생성자호출할 때 사용
- 부모의 멤보는 부모의 생성자를 호출해서 초기화. 
- 자식은 자식이 선언한 것만 초기화 하는게 좋다.
예시)
```commandline
class Point {
  int x, y;
  
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}

class Point3D extends Point {
  super(x, y); // 부모의 생성자 Point(int x, int y)를 호출
  this.z = z;
}
```

#### super() 조건

- 생성자의 첫 줄에 반드시 다른 생성자를 호출(생성자 체이닝). 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

### 제어자(modifier)

- 하나의 대상에 여러 제어자를  사용가능(접근 제어자는 하나만)

#### 제어자의 종류

- 접근 제어자
    - public: 접근 제한 없다. 하나의 파일안에 한개만 사용 가능. 파일명과 이름 같아야한다.
    - protected: 같은 패키지, 다른 패키지의 자식클래스에서 접근 가능
    - default: 같은 패키지 내에서만 접근 가능
    - private: 같은 클래스 내에서만 접근 가능
- 그외
    - static
      - 멤버변수: 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하며 클래스가 메모리에 로드될 때 생성됨.
      - 메서드: static 메서드 에서는 iv, instatnce 메서드 사용불가
    - fianl
      - 클래스: 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
      - 메서드: 변경될 수 없는 메서드. 오버라이딩 사용 불가
      - 멤버변수, 지역변수: 값을 변경할 수 없는 상수
    - abstract
      - 클래스: 구현부가 없는 메서드(선언부만 존재), 인스턴스 생성 불가. 추상클래스를 상속받아서 완전한 클래스를 만든후에 객체생성 가능.
      - 메서드: 선언부만 작성

### 캡슐화

- 접근 제어자를 사용하는 이유
  - 외부로부터 데이터를 보호하기 위해서
  - 외부에는 불필요한 내용을 감추기 위해서
- 외부로부터의 직접접근을 막고 메서드를 통한 간접접근을 허용시킨다.

### 다형성

- 부모 타입 참조 변수로 자식 타입의 객체를 다루는 (타입이 불일치해도 괜찮다!)
예) ```Tv t = new smartTv();```
- Tv: 참조변수 타입
- t: 생성된 객체를 참조하는 변수명
- new: 새로운 객체를 힙메모리에 생성한다는 키워드
- SmartTv(): 실제로 생성되는 객체의 타입

- 자식 타입의 참조변수로 부모 타입의 객체를 가리킬 수 없다.

### 참조변수의 형변환

- 타입을 일치시켜 주는 것만 한다.
- 사용할 수 있는 멤버의 갯수를 조절하기 위해 한다.(부모자식 관계일 경우에만 가능)
- 리모콘을 변경함으로써 사용할 수 있는 멤버의 개수를 조절하는게 참조변수의 형변환
- 참조변수가 가리키는 실제 객체가 중요하다.(실제 객체의 멤버 개수가 n개 이면 그 n개 안에서 놀아야함 자손에서 조상으로 바꾸는건 멤버 개수가 줄어드니까 상관없는데
조상에서 자손으로 바꾸려면 에러가 뜰 수도 있음)
- 컴파일러는 형변환만 맞으면 에러를 안띄운다. 하지만 실제 객체가 해당 멤버를 가지고 있지 않으면 에러가 뜬다.

#### instanceof

- 형변환하기전에 instanceof 연산자로 반드시 확인하고 해야함
예)
```commandline
void doWork(car c) {
  if(c instanceof FireEngine) {    // 1.형변환 가능한지 확인 
    FireEngine fe = (FireEngine)c; // 2.형변환
    fe.water();
  } else if(c instanceof Ambul) {
    Ambul a = (Ambul)c;
  }
}
```

### 매개변수의 다형성

- 다형성에 대해서 정리해보자
  - Tv t = new SmartTv();
  - 참조변수의 형변환 -> 리모콘 바꾸기: 사용가능한 멤버갯수 조절
  - instanceof연산자: 형변환 가능여부 확인

#### 다형성의 장점

1. 다형적 매개변수
   - 참조형 매개변수는 메서드 호출시 자신과 같은 타입 또는 자손타입의 인스턴스 넘겨주기 가능
2. 하나의 배열로 여러종류 객체를 저장할 수 있다.
