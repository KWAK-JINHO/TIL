> 데이터 중심 애플리케이션 설계 요약 및 정리

# Part 1 데이터 시스템의 기초

## 1장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 현대에는 CPU 중심(계산 중심)보다 I/O 중심(데이터 중심)적이다. 이는 **데이터의 양**, **데이터의 복잡도**, **데이터의 변화 속도**가 주요 문제로 대두되었기 때문이다.
- 성공적으로 추상화된 데이터 시스템은 다음과 같은 요소를 포함한다:
    - **데이터베이스**
    - **캐시**
    - **인덱스**
    - **스트림 처리**
    - **일괄 처리**

### 최근 Application들의 구성

1. 클라이언트 요청.
2. 데이터가 인메모리 캐시에 있는지 확인하여 읽기 요청 → 예: Redis.
3. 캐시 미스일 경우 기본 DB에 읽기 요청 또는 쓰기 요청(새로운 쓰기 포함).
4. 캐시 무효화 또는 갱신(새로운 쓰기 포함).
5. 검색 요청 → 예: Solr, Elasticsearch.
6. 비동기 태스크는 메시지 큐 사용 → 예: Kafka (배치 처리, 작업 큐).

### 소프트웨어 설계의 세 가지 관심사

1. **신뢰성**: 정확히 원하는 기능을 수행해야 한다.
2. **확장성**: 데이터의 양이 증가해도 대처 가능해야 한다.
3. **유지보수성**: 코드와 시스템이 쉽게 수정 및 개선될 수 있어야 한다.

### 신뢰성

- 시스템은 **내결함성**을 갖추어야 한다. 단, 특정 유형의 결함에 대해 내성을 제공해야 함.
- 회복성이 중요하다.

#### 하드웨어 결함에 대한 대응

1. **구성 요소에 중복을 추가**:
    - 디스크: RAID 구성으로 설치하여 장애 복구 가능 → RAID 1, 2, 3 등 검색 추천.
    - 서버: 이중 전원 디바이스와 핫스왑 가능한 CPU를 이용.
    - 단일 장비의 전체 장애는 매우 드물지만, 다중 장비의 중복은 고가용성(피크 타임에도 문제 없이 작동)을 필요로 하는 애플리케이션에서 필수적이다.
2. 데이터 양 증가로 인해 장비 수가 증가하는 추세.

#### 소프트웨어 오류

- **시스템 내 체계적 오류**: 노드 간 상관관계로 인해 상관 없는 하드웨어 결함보다 더 많은 오류를 유발.
- 소프트웨어의 체계적 오류는 신속히 해결하기 어렵다.

#### 인적 오류

1. 장애 발생 가능 부분을 분리.
2. 철저한 테스트 진행.
3. 모니터링 시스템(로깅 시스템) 구비.

### 확장성

미래의 부하를 예측하고 대비해야 한다.

#### 부하 기술하기

- **부하 매개변수**: 예상 부하를 기준으로 하드웨어 요구 수준을 평가해야 한다.

#### 트위터의 사례

1. 초기에는 RDB(정형 데이터베이스)를 사용해 데이터를 관리하고 테이블에 기록.
2. 시스템이 홈 타임라인의 질의 부하를 버티기 힘들어지면서 방식 변화 발생:
    - 메시지 큐를 이용하여 새 트윗을 큐에 태우고 팔로워들에게 전송.
    - 게시 요청량은 홈 타임라인 읽기 요청량보다 훨씬 적음.
    - 하지만 팔로워 수가 많아지면 부담 증가.
3. 최적화를 위해 1번과 2번 방식을 결합.

### 성능 기술하기

1. **지연 시간**: 서버 입장에서 처리 소요 시간.
2. **응답 시간**: 클라이언트 입장에서의 소요 시간.
3. **중앙값(Median) 사용**:
    - 평균값은 특이값(Outlier)을 반영하여 전체 성능을 왜곡할 수 있음.
    - 중앙값을 통해 성능의 실제 분포를 파악.

# 클라이언트 측 응답시간의 중요성

- 클라이언트의 응답시간은 사용자 경험에 큰 영향을 미친다.
- 소수의 느린 요청 처리만으로도 후속 요청 처리가 지연될 수 있으며, 이를 **선두 차단(head-of-line blocking)**이라고 한다.
- 최종 사용자 요청에서는 **지연이 큰 요청(Outlier)**이 시스템 성능을 좌우하므로, 이를 줄이는 것이 중요하다.
- 성능 분석 시 **중앙값(Median)**을 사용하는 것이 평균값보다 효과적이다. 병렬 처리가 이루어져도 최종 응답시간은 가장 느린 요청이 결정한다.

# 부하 대응

1. **스케일 업 (Scale-Up)**
    - 하나의 장비를 더 강력한 성능으로 업그레이드.
2. **스케일 아웃 (Scale-Out)**
    - 여러 장비를 추가하여 부하를 분산.

### 다수 장비를 통한 부하 분산: 비공유 아키텍처 (Shared-Nothing Architecture)

- **Stateless**:
    - 상태를 저장하지 않아 간단하다.
    - 개별 요청 간의 의존성이 없어 확장성 용이.
- **Stateful**:
    - 상태를 저장해야 하므로 동기화가 필요.
    - 복잡도가 올라가며 유지보수 어려움.

# 유지보수성

소프트웨어 비용의 대부분은 유지보수에서 발생한다. 이를 개선하기 위한 설계 원칙은 다음과 같다:

1. **운용성 (Operability)**
    - 시스템이 쉽게 운영되고 관리 가능해야 한다.

2. **단순성 (Simplicity)**
    - 단순함은 기능을 줄이라는 의미가 아니라, **우발적 복잡도(accidental complexity)**를 줄이자는 의미이다.
    - "추상화"를 통해 복잡성을 줄이는 것이 중요하다.

3. **발전성 (Evolvability)**
    - 소프트웨어가 쉽게 변경 가능해야 한다.
    - 새로운 요구사항이나 변경사항에 유연하게 대처할 수 있는 설계가 필요하다.

# 데이터 모델과 질의 언어

- **문제를 어떻게 생각할 것인지**를 결정한다.
- 각 계층의 **명확한 데이터 모델**을 정의하여, 하위 계층의 복잡성을 "추상화"로 숨길 수 있다.

## 관계형 모델과 문서 모델

1. **관계형 모델**
    - 데이터는 "관계"로 구성된다.
    - 관계는 **튜플(객체)**의 집합으로 구성된다. (SQL에서는 **row**에 해당)

2. **문서 모델**
    - 데이터는 비정형 데이터를 다룰 수 있는 구조로 설계된다.
    - 예: NoSQL은 유연한 데이터 모델을 제공하며, 관계형 데이터베이스는 정형 데이터를 다룬다.

## 객체-관계형 불일치 (Object-Relational Impedance Mismatch)

- 객체 지향 프로그래밍과 관계형 데이터베이스 간의 데이터 모델 차이로 인해 발생하는 문제.
- 데이터를 저장하고 질의하는 방식의 차이에서 비롯된 복잡성을 다룰 필요가 있다.

### 일대 다 관계

- 트리구조를 형성한다.

### 다대일 다대다 관계

- 문서모델에서는 다대다(예시 학생-수강신청)가 어렵다.
- 중복된 데이터를 정규화하려면 다대일 관계가 필요.
- 다대일 관계는 문서 모델에 적합하지 않다. -> RDB에서는 조인이 쉽다(변경이 어려움) -> ID로 다른 테이블의 로우를 참조

### 네트워크 모델

- 다대다 표현이 쉬움

### 관계형 모델

- 관계는 단순히 로우(객체)의 컬렉션(객체 배열)이 전부
- DB는 저장순서를 안따진다.
- 관계형 모델과 문서 모델
    - 데이터는 "관계"로 구성
    - 관계는 "튜플(객체)" (SQL row)의 집합
- NOSQL: 비정형 -> 유연함
    - RDB는 정형
- 객체 관계형 불일치