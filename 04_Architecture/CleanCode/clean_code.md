# 의도를 분명하게 드러내기

- 이름은 읽는 사람이 바로 이해할 수 있도록 **명확하고 직관적으로** 짓는다.
- 잘못된 정보, 비슷한 이름, 일관되지 않은 표기를 피한다.
- 클래스는 **명사**, 메서드는 **동사** 기반으로 일관되게 작성한다.
- 한 개념에는 한 단어를 반복적으로 사용해 혼동을 없앤다.
- 타입, 구조 같은 외적 정보는 변수명에 넣지 않는다(IDE가 담당).
- 읽기 어렵거나 발음/검색이 힘든 이름은 피한다.

# 읽기 흐름이 깨지지 않는 코드 작성

- 메인 로직은 직선적인 흐름으로 읽혀야 한다.
- 예외 처리, 로깅, 조건 체크, null 처리 등은 **중간중간 끼어들어 흐름을 끊지 않도록** 한다.
- 필요 시 가드 클로즈(보호절)를 초기에 배치하여 본 로직을 방해하지 않게 한다.
- null 처리는 최소화하고, 쓰는 경우 **위치·패턴을 일관되게** 한다.
- 메인 기능과 안전장치를 한 화면 안에 뒤섞지 않는다.

# 작은 단위로 나누기 (함수 / 클래스)

## 함수

- 짧고 더 짧게 만든다.
- 조건문·반복문 등은 한 줄짜리 함수 호출로 추상화하여 중첩을 방지한다.
- 하나의 함수는 **한 가지 일**만 한다.
- 추상화 수준을 섞지 않는다.
- 인자를 최소화한다.
- 객체의 상태를 변경하거나 정보를 반환하거나 **둘 중 하나만** 책임지게 한다.

## 클래스

- 클래스는 작고 응집력 있게 만들며, 책임이 분리되어 있어야 한다.
- 클래스 이름은 해당 클래스의 책임을 설명해야 한다.
- 단일 책임 원칙(SRP)을 중심으로 필요한 경우 클래스를 분리한다.
- 캡슐화는 원칙이지만 ‘무조건 숨기는 것’보다는 **의존성 관리**가 핵심이다.

# 관심사 분리

- 핵심 로직과 주변부 로직(로깅, 검증, 예외, null 처리)을 분리한다.
- 시스템 차원에서도 관심사를 레이어로 나누고, DI(의존성 주입)를 통해 결합도를 낮춘다.
- 사용과 제작을 분리하여 테스트 가능성과 모듈성을 높인다.
- 잘 분리된 코드일수록 유지보수가 쉽고 테스트가 단순해진다.

# 일관성 있는 코드 구조

- 형식(코드 스타일)은 유지보수성과 협업 품질의 핵심이다.
- 서로 밀접한 개념은 한 파일 또는 인접한 위치에 둔다.
- 호출하는 함수는 호출되는 함수보다 위쪽에 두어 읽기 흐름이 자연스럽게 한다.
- 변수는 사용하는 지점 가까이에 선언한다.
- null 처리 방식, 예외 처리 방식, 로깅 규칙 등은 코드베이스 전체에서 동일해야 한다.

# 중복 제거

- 동일한 로직, 동일한 분기, 동일한 예외 처리, 동일한 null 처리 패턴은 중복되지 않도록 한 곳에서 관리한다.
- 중복 제거는 응집도를 높이고 결합을 낮추며, 유지보수 비용을 크게 줄인다.

# 단위 테스트의 역할

- 테스트는 실제 코드만큼 중요하며, 변경에 강하고 단순해야 한다.
- 잘 설계된 테스트는 SRP 준수를 자연스럽게 유도한다.
- 최소한의 표현으로 많은 의미를 담는 가독성 높은 테스트가 목표다.
- 테스트가 잘 갖춰져야 창발적 설계(좋은 구조)가 자연스럽게 만들어진다.

# 시스템 설계와 클린코드

- 깨끗한 아키텍처는 명확한 추상화와 관심사 분리가 기반이다.
- DI, 레이어 분리, 초기화 절차 분리 등을 통해 모듈성과 확장성을 확보한다.
- 경계(입출력, 예외 처리, 로깅)는 시스템 바깥에서 처리하여 핵심 로직을 보호한다.
- 관심사 분리가 성공하면 테스트 주도 아키텍처(TDA) 구축도 용이해진다.

# 동시성 고려

- 동시성은 복잡성이 높기 때문에 “무엇을 할지”와 “언제 실행되는지”를 분리해야 한다.
- 공유 상태를 최소화하고, 가능한 독립된 실행 흐름으로 설계한다.
- 동시성은 관리 가능한 구조에서만 사용해야 한다.

# 좋은 코드를 위한 태도

- 잘 유지되고 규모 있는 코드베이스를 꾸준히 읽으며 구조적 패턴을 체득한다.
- 인문·교양 도서 등을 통해 표현력, 사고력, 문제 정리 능력을 기르는 것도 코딩에 도움이 된다.
- 궁극적으로 클린코딩은 **사람이 읽기 쉬운 코드**를 추구하는 태도이다.
