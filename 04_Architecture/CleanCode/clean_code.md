# Clean Code

# 이름짓기

- 읽는 사람이 바로 이해할 수 있도록
- 일관된 규칙
- 한 개념에는 한 단어만 사용

# 읽기 흐름이 깨지지 않는 코드 작성

- 메인 로직은 직선적인 흐름으로 읽혀야 한다.
- 예외 처리, 로깅, 조건 체크, null 처리 등은 중간중간 끼어들어 흐름을 끊지 않도록 한다.
- 필요 시 가드 클로즈를 배치하여 본 로직을 방해하지 않게 한다.
- null 처리는 최소화하고, 쓰는 경우 위치·패턴을 일관되게 한다.
- 메인 기능과 안전장치를 한 화면 안에 뒤섞지 않는다.

# 작은 단위로 나누기 (함수 / 클래스)

## 함수

- 짧게 만들자.
- 하나의 함수는 한 가지 일만 한다.
- 조건문·반복문 등은 한 줄짜리 함수 호출로 추상화하여 중첩을 방지한다.
- 추상화 수준을 섞지 않는다.
- 인자를 최소화한다.
- 객체의 상태를 변경하거나 정보를 반환하거나 **둘 중 하나만** 책임지게 한다.

## 클래스

- 클래스는 작고 응집력 있게 만들며, 책임이 분리되어 있어야 한다.
- 클래스 이름은 해당 클래스의 책임을 설명해야 한다.
- 단일 책임 원칙(SRP)을 중심으로 필요한 경우 클래스를 분리한다.
- 캡슐화는 원칙이지만 ‘무조건 숨기는 것’보다는 **의존성 관리**가 핵심이다.

# 관심사 분리

- 핵심 로직과 주변부 로직(로깅, 검증, 예외, null 처리)을 분리한다.
- 시스템 차원에서도 관심사를 레이어로 나누고, DI(의존성 주입)를 통해 결합도를 낮춘다.
- 사용과 제작을 분리하여 테스트 가능성과 모듈성을 높인다.
- 잘 분리된 코드일수록 유지보수가 쉽고 테스트가 단순해진다.

# 일관성 있는 코드 구조

- 형식(코드 스타일)은 유지보수성과 협업 품질의 핵심이다.
- 서로 밀접한 개념은 한 파일 또는 인접한 위치에 둔다.
- 호출하는 함수는 호출되는 함수보다 위쪽에 두어 읽기 흐름이 자연스럽게 한다.
- 변수는 사용하는 지점 가까이에 선언한다.
- null 처리 방식, 예외 처리 방식, 로깅 규칙 등은 코드베이스 전체에서 동일해야 한다.

# 중복 제거

- 동일한 로직, 동일한 분기, 동일한 예외 처리, 동일한 null 처리 패턴은 중복되지 않도록 한 곳에서 관리한다.
- 중복 제거는 응집도를 높이고 결합을 낮추며, 유지보수 비용을 크게 줄인다.

# 단위 테스트의 역할

- 테스트는 실제 코드만큼 중요하며, 변경에 강하고 단순해야 한다.
- 잘 설계된 테스트는 SRP 준수를 자연스럽게 유도한다.
- 최소한의 표현으로 많은 의미를 담는 가독성 높은 테스트가 목표다.
- 테스트가 잘 갖춰져야 창발적 설계(좋은 구조)가 자연스럽게 만들어진다.

# 시스템 설계와 클린코드

- 깨끗한 아키텍처는 명확한 추상화와 관심사 분리가 기반이다.
- DI, 레이어 분리, 초기화 절차 분리 등을 통해 모듈성과 확장성을 확보한다.
- 경계(입출력, 예외 처리, 로깅)는 시스템 바깥에서 처리하여 핵심 로직을 보호한다.
- 관심사 분리가 성공하면 테스트 주도 아키텍처(TDA) 구축도 용이해진다.

# 동시성 관리

- “무엇을 할지”와 “언제 실행되는지”를 분리
- 공유 상태를 최소화하고, 가능한 독립된 실행 흐름으로 설계한다.
- 동시성은 관리 가능한 구조에서만 사용해야 한다.

# 좋은 코드를 위한 태도

- 잘 유지되고 규모 있는 코드베이스를 꾸준히 읽으며 구조적 패턴을 체득한다.
- 인문·교양 도서 등을 통해 표현력, 사고력, 문제 정리 능력을 기르는 것도 코딩에 도움이 된다.
- 궁극적으로 클린코딩은 **사람이 읽기 쉬운 코드**를 추구하는 태도이다.

---

# 설계의 본질은 의존성을 관리하는 것

- 코드를 어디에 배치할지 결정하는 것이 '설계', 핵심은 변경에 초점을 맞추는 것.
- 의존성: B가 바뀔 때 A도 바뀔 가능성

## 주의사항

- 양방향 의존성은 피해야 한다.
- 불필요한 의존은 제거.
- 컬렉션 참조 지양
- 패키지 사이의 의존성 사이클은 제거 대상

### 의존성 사이틀을 끊는 방법 3가지

1. 중간 객체 생성: 공통 데이터를 추상화한 클래스로 변환하여 의존성 방향을 정리
2. DIP: 인터페이스를 사용해 구체적인 구현에 의존하지 않게 함
3. 패키지 분리: 새로운 도메인개념을 도출해 분리

# 객체 참조 VS ID 참조

- 모든 객체가 연결되어 있으면 트랜잭션 경계가 모호해지고 , DB 락 경합으로 인해 성능과 응답성이 저하된다.
- ID 참조의 이점: 객체간 결합도를 낮추고 트랜잭션/조회 범위를 명확히 나눠야한다.
- Aggregate만 객체로 묶고, 나머지는 ID로 분리

# 로직 파편화 해결

- 객체 안에 로직을 억지로 넣기보다 validator나 서비스에서 처리하는 것이 응집도가 더 높을 수 있다.
- 특정 상태 변경 후 후속 작업이 필요할 때 직접 호출 대신 이벤트를 발행해 결합도를 낮춘다.

---

# 🔗

- [유튜브 영상: [우아한테크세미나] 190620 우아한객체지향 by 우아한형제들 개발실장 조영호님](https://www.youtube.com/watch?v=dJ5C4qRqAgA&t=310s)