# 인증과 인가

- 인증(Authentication): 사용자의 신원을 검증하는 행위
- 인가(Authorization): 확인된 사람이 무엇을 할 수 있는지 결정하는 과정

# 인증 방식

- JWT (Json Web Token): 토큰 자체에 정보가 포함되어있는 클레임 기반 토큰.
- Session: 사용자의 상태정보를 서버에 저장하고, 서버와 클라이언트 간의 연결 기간 동안 상태를 유지하게 해준다.
- OAuth 2.0 (소셜 로그인): 카카오 네이버 구글 등 외부 인증 서버를 통해 사용자 신원을 확인.
- Spring Security
    1. 보안표준: 보안기능을 업계표준에 맞게 구현해놓았음(CSRF, 세션관리, 비밀번호 해싱 등)
    2. 다양한 인증 방식(폼 로그인, OAuth2, JWT 등)과 같은 복잡한 인가 규칙을 설정으로 적용 및 확장이 가능

# 보안 주의 사항

### CORS(Cross-Origin-Resource Sharing)

웹 브라우저는 동일 출처 정책(SOP)이라는 보안 규칙을 따르기 때문에 로드된 문서는 자신과 동일한 출처에서 온 자원(데이터, 스크립트)만 접근할 수 있다.

프로토콜, 도메인, 포트 -> 이 세가지가 모두 일치해야 동일 출처로 간주

서버에 접근가능한 출처를 명시하여 악성 웹사이트에서 사용자가 로그인된 사이트로 중요 데이터를 요청했을때 요청을 차단.

#### Preflight

요청의 복잡도를 판단해 브라우저는 서버에 요청을 보내기 전에 'OPTIONS' 요청을 보낸다. 이를 "Preflight"라고 한다.
(복잡도는 HTTP메서드, 헤더에 어떤 값이 포함 되는지, Content-Type이 무엇인지를 따져 판단)

OPTIONS요청은

- 해당 Origin에서 요청을 보내도 되는지
- 해당 HTTP 메서드와 헤더를 보내도 되는지

를 브라우저가 서버에게 물어보는 작업.

---

### CSRF(Cross-Site Request Forgery)

사이트간 요청 위조로 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 만드는 공격

예시)

- 내가 은행에 로그인 되어있는상태에서 공격자가 만든 사이트를 이용했을때 은행의 쿠키가 있는것을 이용해 해당 쿠키를 사용해 돈을 송금.

주요 방어 대책으로는

- CSRF Token: 서버가 요청 시마다 고유한 토큰을 발행하고, 클라이언트가 모든 요청에 이 토큰을 포함시켜 전송하면 서버가 검증
- SameSite Cookie: 쿠키 전송을 제한하여, 외부 사이트(Cross-Site) 요청에는 쿠키가 자동으로 전송되지 않도록 한다.
- 출처 검사: 요청이 발생한 출처가 신뢰할 수 있는 도메인인지 확인

---

### XSS

Cross-Site Scripting 사이트 간 스크립팅을 의미

공격자가 악성 스크립트를 웹에 삽입하려 사용자 브라우저에서 실행.

예시)
내가 만든 웹페이지에 DB변경 요청을할때 스크립트를 심어 저장. 다른 사용자들이 해당 기능을 이용할때마다 스크립트가 실행되게 하여 공격

공격 유형

- Stored XSS (저장형): 악성 스크립트가 서버의 데이터베이스(게시판 내용, 댓글 등)에 저장되었다가, 다른 사용자가 해당 페이지를 열 때마다 실행됩니다.
- Reflected XSS (반사형): 악성 스크립트가 URL 파라미터 등을 통해 서버로 전달된 후, 서버의 응답에 반사되어 사용자 브라우저에서 실행됩니다.
- DOM-based XSS (DOM 기반): 서버를 거치지 않고, 브라우저에서 스크립트가 DOM 환경을 조작하여 실행됩니다.

주요 방어 대책:

- 입력값 필터링/검증: 사용자에게서 받은 모든 입력값을 허용된 형태로만 받도록 강력하게 검증
- 출력값 이스케이프 (Escape): 서버에서 사용자 입력값을 화면에 출력하기 전에 `<`와 `>` 같은 스크립트 실행에 사용되는 특수문자를 단순 문자열로 치환하여 (`&lt;`, `&gt;`) 브라우저가
  스크립트로 인식하지 못하게 한다.