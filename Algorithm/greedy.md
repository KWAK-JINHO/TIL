# 그리디 알고리즘(탐욕법)

- 매 순간 가장 최적인 선택을 하는 방식으로 전체 문제를 해결하는 해결하는 것이 목표.
- 항상 최적의 해를 보장하지는 않고, 최적의 값에 가까운 근사한 값을 목표로 한다.

### 그리디 알고리즘을 적용할때 성립해야 하는 두가지 조건

1. 탐욕 선택 속성
- 각 단계에서의 최선의 선택이 전체 문제의 최적해로 이어짐을 보여준다.

2. 최적 부분 구조
- 전체 문제가 여러 개의 부분 문제로 나누어질 수 있을을 보여준다.

### 그리디 알고리즘의 일반적인 단계

1. 최적해 구조 결정
2. 선택 절차 정의 -> 현재 단계에서 최적의 선택을 한다.
3. 선택 수행
4. 적절성 검사 : 선택한 항목이 문제의 조건을 만족시키는지 확인.
5. 부적절한 해 제외
6. 해답 검사: 최종 선택이 문제의 조건을 만족시키는지 확인

- 위 단계는 유연하게 적용될 수 있다.

### 효과적인 문제들

- 활동 선택 문제
- 최소 신장 트리
- 최단 경로 알고리즘

### 그리디 알고리즘 예시

- 거스름돈
```
def coin_change_greedy(amount, coins):
    # 1. 최적해 구조 결정: 가장 큰 동전부터 사용하는 것이 최적임을 가정
    
    # 2. 선택 절차 정의: 동전을 크기 순으로 정렬
    coins.sort(reverse=True)  # 동전을 내림차순으로 정렬
    
    change = []
    
    # 3. 선택 수행 및 4. 적절성 검사를 반복
    for coin in coins:
        while amount >= coin:
            # 3. 선택 수행: 현재 동전 선택
            amount -= coin
            change.append(coin)
            
            # 4. 적절성 검사: 남은 금액이 현재 동전보다 작은지 확인
            # (while 조건에서 자동으로 수행됨)
    
    # 5. 부적절한 해 제외: 
    # (이 알고리즘에서는 모든 선택이 항상 적절하므로 이 단계가 명시적으로 필요 없음)
    
    # 6. 해답 검사: 모든 금액이 거슬러졌는지 확인
    if amount == 0:
        return change
    else:
        return "거스름돈을 만들 수 없습니다."

# 사용 예시
amount = 1260
available_coins = [500, 100, 50, 10]
result = coin_change_greedy(amount, available_coins)

print(f"필요한 동전: {result}")
print(f"총 동전 개수: {len(result)}")
```