# 쓰레드(Thread)

쓰레드는 프로세스 내에서 실제 작업을 수행하는 실행 단위로, 하나의 프로세스는 여러 쓰레드를 가질 수 있으며, 각 쓰레드는 프로세스의 메모리를 공유하면서
개별적으로 실행된다..

---

## **쓰레드의 종류**

컴퓨터 시스템은 크게 세 가지 계층으로 나뉠 수 있다:

1. **사용자 프로그램(User Program)**
2. **운영체제 커널(OS Kernel)**
3. **하드웨어(Memory / CPU / Devices)**

### **1. 하드웨어 레벨(혹은 CPU 레벨)의 쓰레드**

#### **코어의 문제점**

- 코어는 CPU 내부에서 실제 연산을 수행하는 단위로, 독립적으로 명령어를 처리
- 프로그램 실행 중 메모리 접근(읽기/쓰기) 시 대기 시간이 발생하는데, 이는 연산 작업에 비해 상대적으로 오래 걸린다.
- **해결 방안**: 메모리를 기다리는 동안 코어가 다른 쓰레드를 실행하도록 함.

#### **하드웨어 쓰레드(Hardware Thread)**

- **하드웨어 쓰레드**는 코어가 두 개의 쓰레드를 번갈아 실행하여 대기 시간을 줄이고 효율성을 높이는 방식
- **인텔 하이퍼스레딩(HT)** 기술: 하나의 물리적 코어가 두 개의 하드웨어 쓰레드를 실행함.
- **OS 관점**: 하드웨어 쓰레드를 가상의 논리적 코어(Logical Core)로 인식
- 예를 들어, 싱글 코어 CPU가 두 개의 하드웨어 쓰레드를 지원하면, OS는 해당 CPU를 듀얼 코어로 인식하여 스케줄링을 수행

### **2. OS 쓰레드**

- **정의**: 운영체제 커널 레벨에서 생성되고 관리되는 쓰레드를 의미.
- **다른 이름**: 커널 쓰레드(Kernel Thread) 또는 커널 레벨 쓰레드.
- **특징**:
    - CPU에서 실제로 실행되는 단위이며, CPU 스케줄링의 단위.
    - 컨텍스트 스위칭 시 커널이 개입하여 수행.
    - 사용자 모드와 커널 모드 간 전환이 이루어지며, 이 과정에서 CPU 리소스가 사용되기 때문에 **비용**이 발생.

#### **컨텍스트 스위칭**

- OS 쓰레드는 컨텍스트 스위칭 시 **유저 모드**에서 **커널 모드**로 전환되어 커널 코드가 실행.
- 시스템 호출(System Call)이 완료되면 다시 유저 모드로 돌아가 사용자 코드가 실행.

#### **예시**:

- 사용자가 작성한 코드가 OS 쓰레드에서 실행되며, 중간에 시스템 호출이 이루어지면 모드 전환이 발생.

### **3. 사용자 쓰레드(User Thread)**

- **정의**: OS와 독립적으로 사용자 레벨에서 관리되는 쓰레드.
- **특징**:
    - 커널 모드의 개입 없이 사용자 모드에서 스케줄링이 이루어짐.
    - 문맥 교환도 사용자 수준에서 수행됨.
    - 프로그래밍 레벨에서 추상화된 개념.

#### **Java 쓰레드 예제**:

```java
Thread thread = new Thread(); // 쓰레드 객체 생성
thread.

start(); // 쓰레드 시작
```

- `start()` 메서드 호출 시 내부적으로 JNI(Java Native Interface)를 통해 OS의 시스템 호출이 이루어짐.
    - ** JNI(Java Native Interface): JVM에서 다른 언어를 사용할 수 있게 한다.
- 리눅스 환경에서는 `clone()` 시스템 호출을 통해 OS 레벨의 쓰레드를 생성하고, 이 쓰레드가 Java 쓰레드와 연결.

#### **중요 포인트**:

- **유저 쓰레드가 CPU에서 실행되려면 반드시 OS 쓰레드와 연결**되어야 한다.
- CPU에서 실제 실행되는 단위는 OS 쓰레드

---

### **OS 쓰레드와 사용자 쓰레드의 연결 모델**

#### **1. One-to-One 모델**

- **설명**: 하나의 사용자 쓰레드가 하나의 OS 쓰레드와 1:1로 연결됨.
- **특징**:
    - 쓰레드 관리(스케줄링 포함)를 OS에 위임함.
    - 멀티코어 시스템에서 OS 쓰레드를 잘 배분하여 실행할 수 있음.
    - 사용자 쓰레드가 `Block I/O`에 걸리면 연결된 OS 쓰레드도 블록됨.
    - 다른 OS 쓰레드들은 영향을 받지 않음.
    - 하지만 1:1 관계로 인해 race condition 발생 가능성 존재

#### **2. Many-to-One 모델**

- **설명**: 여러 사용자 쓰레드가 하나의 OS 쓰레드에 연결되는 모델.
- **특징**:
    - 컨텍스트 스위칭이 빠름(커널 개입 없이 사용자 모드에서 처리).
    - `Block I/O`가 발생하면 전체 사용자 쓰레드가 블록됨.
    - 멀티코어를 활용하지 못함.

#### **3. Many-to-Many 모델**

- **설명**: 여러 사용자 쓰레드가 여러 OS 쓰레드와 연결되는 모델.
- **특징**:
    - 컨텍스트 스위칭이 빠르고 멀티코어를 활용함.
    - 한 개의 쓰레드가 블록되더라도 전체가 블록되지 않음.
    - 구현이 복잡함.

---

### **그린 쓰레드(Green Thread)**

- Java 초기 버전에서는 **Many-to-One 쓰레딩 모델**을 사용했으며, 이를 **그린 쓰레드(Green Thread)**라고 부른다.
- 현재는 OS와 독립적으로 사용자 레벨에서 스케줄링되는 쓰레드를 의미하기도 하며, 맥락에 따라 사용자 쓰레드와 같은 의미로 사용될 수 있다.
