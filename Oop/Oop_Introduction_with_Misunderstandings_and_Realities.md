# 객체지향의 사실과 오해 정리
<br>

## 1. 협력하는 객체들의 공동체
1장 에서는 이해를 돕기위해 객체를 손님,캐시어,바리스타로 비유한다. 각 "**역할**"은 "**책임**"을 가지고 서로 요청과
응답을 주고 받으며 "**협력**"하는 존재로 설명되고 있다.

### 객체의 특징
  1. 여러 객체가 동일한 역할을 수행할 수 있다.
  2. 역할은 대체 가능성을 의미한다.
  3. 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
  4. 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

### 객체의 덕목
   1. 서로 충분히 **협력적** 이여야 한다.
   2. 충분히 **자율적** 이여야 한다. 요청에 대한 응답을 스스로의 원칙에 따라서 판단, 결정할 수 있어야 한다.
      - 객체의 자율성은 내부와 외부를 명확하게 구분하는 것으로부터 나온다. 다른 객체가 '무엇'을 할지는 알지만 '어떻게'
          수행되는지는 알 수 없어야 한다. *이것이 데이터와 프로세스를 엄격하게 구분하는 전통적인 개발방법과 객체지향을 구분짓는 핵심적인 차이다.*
      - 자율성은 유지보수가 쉽고 재사용성이 용이한 시스템을 구축할 가능성을 제시한다.

### OOP의 주요개념 (책내용 아님)

   1. 추상화
      - 복잡한 시스템에서 핵심적인 부분만을 모델링하여 불필요한 세부사항은 숨기는 기법

   2. 상속
      - 부모클랫의 속성과 메소드를 새로운 클래스가 물려받아 재사용하는 기법

   3. 다형성
      - OOP에서 하나의 인터페이스를 통해 여러 다른 타입의 객체를 다룰 수 있는 능력.
      - 보통 두가지 형태로 나타난다.
         1. overloading : 컴파일 시간 다형성을 구현하는 방식으로 같은 이름 메서드가 여러개 정의된다. (매개변수의 타입, 개수, 또는 순서가 달라야 한다.)
         2. overriding : 상속 관계에 있는 부모 클래스의 메소드를 자식 클래스에서 재정의하여 사용하는 방식
           oop는 이 두가지를 모두 사용할 수 있으며 overriding이 다른 프로그래밍 언어와 oop를 구분짓는 핵심 적인 특징중 하나이다.
   4. 캡슐화
      - 객체의 내부 상태(속성)와 행동(메소드)을 하나로 묶고 외부에 대한 직접적 접근을 제한하는 기법.
      - 데이터를 보호하고 객체간의 상호작용을 제어할 수 있다.

## 2. 이상한 나라의 객체

### 상태와 행동
   - 객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 상태, 행동, 식별자를 지닌 실체로 보는것이 효과적이다.
   - 객체의 모든 상태는 단순한 값과 객체의 조합으로 표현할 수 있다.
   - 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티라고 한다. (일반적으로 프로퍼티는 고정)
   - 프로퍼티 값은 시간이 흐름에 따라 변경된다.
   - 객체의 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두가지 종료의 조합으로 표현가능하다.
   - 행동은 다른 객체로 하여금 간접적으로 객체의 상태를 변경하는 것을 가능하게 한다. 객체지향의 기본 사상은 상태와 상태를 조작하기
     위한 행동을 하나의 단위로 묶는 것이라는 점을 기억하자. 객체는 스스로의 행동에 의해서만 상태가 변경되는것을 보장함으로써 객체의 자율성을 유지.

### 기계로서의 객체
여기서는 객체를 차가운 금속 외피로 둘러쌓인 블랙박스로 비유한다.
   - 객체의 상태를 조회하는것은 **쿼리**, 상태를 변경하는것은 **명령**
   - 객체에 접근할 수 있는 유일한 방법은 객체 제공하는 행동뿐이다. <br>
     --> <br>
     사용자는 객체가 제공하는 명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.

   - 초보자들이 쉽게 하는 실수는 첫번째로 객체에 필요한 상태가 무엇인지 결정하고 두번째로 그상태에 필요한 행동을 결정 하는것이다. 
     이러한 실수(상태를 먼저 결정하는 실수)는
        1. 캡슐화를 저해시킨다. 공용 인터페이에 상태가 노출될 확률이 높아짐
        2. 객체를 협력자가 아닌 섬으로 만든다.
        3. 객체의 재사용서이 저하.

   - 협력에 참여하는 가장 중요한 덕목은 상태가 아닌 행동에 초점을 맞추는 것.

## 3. 타입과 추상화
추상화의 목적은 복잡성의 극복이다.

### 일반화
   - 클래스들간의 공통적인 속성이나 동작을 추출하여 더 상위의 클래스로 만드는과정
     -->
     이 과정을 통해 코드의 중복을 줄이고 구조를 효율적으로 만든다.
   - 공통적인 부분으로 그룹을 만들었을때 그안의 객체를 그룹의 "인스턴스" 라고 부른다.

### 분류
   - 분류란 객체에 틀정한 개념을 적용하는 일이다. 어떤 객체를 어떤 개념에 분류할것인지
     결정하는 것이 객체 지향의 품질을 결정한다. (객체를 안전하고 적절하게 최대한 직관적으로 분류하자!!)

### 타입
   - 타입의 서술은 개념과 완벽히 일치한다. 타입 시스템의 목적은 데이터가 잘못 되지 않도록 제약을 거는 것이다.

####  객체의 타입
   1. 어떤 객체가 어떤 타입에 들어갈지 결정하는 것은 객체가 수행하는 "행동"이다.
   2. 객체의 행동을 효과적으로 표현할 수만 있으면 내부적으로 상태를 어떻게 표현하더라도 괜찮다.
      - 결과적으로 객체를 타입으로 분류할때 행동만 염두한다.
        행동만 동일하다면 내부적으로 어떤 데이터를 가지고 있던지 같은 타입으로 본다. 여기서 행동이 동일하다는 것은 같은 메시지를 수신
        한다는 뜻이도, 이를 다른 방식으로 처리한다는 의미이다. 이것은 "다형성"에 의미를 부여한다.

### 정적 모델

#### 타입의 목적
   - 타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.
   - 이런 관점에서 타입은 추상화이다.
   - 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. (타입은 시간에 따른 객체의 상태 변경을 단순화 해준다)
   - 동적 모델 vs 정적 모델
      - 동적 모델 : 특정 시점에 구체적으로 어떤 상태를 가지는가
      - 정적 모델(타입 모델): 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것.
         - 클래스를 이용해 구현된다. 따라서 타입을 구현하는 가장 보편적인 방법이 클래스를 이용하는 것.
      - 객체지향 애플리케이션을 설계하고 구현할때 이 둘을 적적히 혼용해야한다.

✎ 객체를 분류하는 기준은 타입, 타입을 나누는 기준은 객체가 수행하는 행동이다.

## 4. 역할, 책임, 협력
어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.
  
### 책임
   - 책임은 객체지향 설계의 가장 중요한 재료
   - 책임을 어떻게 구현할 것인지는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다.
   - 객체지향 설계의 예술은 적절한 객체에게 적절한 책임을 할당하는 데 있다.
   - 책임은 객체의 외부에 제공해 줄 수 있는 정보와 내부에 제공해 줄 수 있는 서비스의 목록. 따라서 책임은 객체의 공용 인터페이스를 구성한다.
   - 설계의 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방식으로 협력해야 하는지에 대한 개요를 아는 것만으로도 충분하다.

### 역할
   - 역할은 재사용이 가능하고 유연한 객체지향 설계를 낳는다.
   - 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.
   - 역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.
   - 역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것
     -> 애플리케이션의 설계를 이해하고 기억하기 쉬워진다.

### 초보자의 흔한오류
   - 객체가 존재하는 이유는 협력에 참여하기 위해서, 실제로 중요한 것은 객체의 행동, 즉 책임이다.
   - 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다. -> 중요한것은 정적인 클래스가 아니라
     협력에 참여하는 동적인 객체(핵심은 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것.)

✎ 객체지향 설계의 핵심은 올바른 객체에 올바른 책임을 할당하는 것. 궁극적으로, 객체들은 자율적이면서도 협력적이여야 하며, 이를 위해 협력의 틀 안에서
자율성을 갖춘 객체를 만들어야 한다.

### 객체지향 설계 기법
   1. 책임 - 주도 설계 : 협력에 필요한 책임들을 식별, 적합한 객체에게 책임을 할당하는 방식
      - 시스템이 제공해야할 기능인 시스템 책임을 파악
      - 시스템 책임을 더 작은 책임으로 분할
      - 분할된 책임을 수행할 적절한 객체 또는 역할을 찾아 책임을 할당
      - 다른 객체의 도움이 필요하면 협력자를 찾아 책임을 위임
      - 협력자와 함께 협력 관계를 형성
   2. 디자인 패턴 : 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿
      - 반복적으로 발생하는 문제와 그에 대한 해법의 쌍
   3. 테스트 주도 개발(TDD) : 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성

## 5. 책임과 메시지

### 자율적인 책임
   - 객체가 자율적으로 책임을 수행하기 위해서는 할당된 책임이 자율적이여야 하며, 구체적인 지시보다 포괄적이고 추상적인 책임이 객체의 자율성을 보장할 수 있다.
   - 책임은 협력의 맥락에 맞게 적절히 추상적이어야 하며, 이를 통해 객체의 자율성을 보장하고 협력의 의도를 명확하게 해야함

#### 코드 예시
   ```
   from abc import ABC, abstractmethod
   
   # 추상적인 음료 클래스
   class Beverage(ABC):
       @abstractmethod
       def prepare(self):
           pass
   
   # 구체적인 음료 클래스들
   class Coffee(Beverage):
       def prepare(self):
           print("Brewing coffee")
   
   class Tea(Beverage):
       def prepare(self):
           print("Steeping tea")
   
   # 바리스타 클래스
   class Barista:
       def prepare_beverage(self, beverage: Beverage):
           # 구체적인 지시 없이 음료를 준비하라는 포괄적이고 추상적인 책임을 부여받음
           beverage.prepare()
   
   # 클라이언트 코드
   barista = Barista()
   coffee = Coffee()
   tea = Tea()
   
   # 바리스타가 다양한 음료를 자율적으로 준비함
   barista.prepare_beverage(coffee)  # "Brewing coffee" 출력
   barista.prepare_beverage(tea)     # "Steeping tea" 출력
   ```
   - 포괄적이고 추상적임 책임: Barista는 음료를 준비하는 책임을 가지지만, 그 책임은 매우 추상적.
     음료가 무엇인지, 어떻게 준비해야 하는지에 대한 구체적인 지시가 없다. 대신 음료 객체는 자신만의 방식으로 자율적으로 음료를 준비.
   - 객체의 자율성 보장 : Barista는 음료 준비에 대한 구체적인 지시 없이, 각 음료 객체가 스스로 자신의 책임을 다하게 한다. 이는 객체의 자율성을 보장.

### 메시지
   - 객체가 다른 객체에 접근할 수 있는 유일한 방법은 요청(메시지)를 전송하는 것 뿐
   - 즉 메시지는 객체로 하여금 자신의 책임을 수행하게 만드는 유일한 방법

### 메서드
   - 메시지를 처리하기 위해 객체가 내부적으로 선택하는 방법

### 다형성
   - 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘
   - 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것.

### 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도, 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.
   1. 협력이 유연해진다.송신자는 수신자가 누구라도 상관하지 않는다.
   2. 협력이 수행되는 방식을 확장할 수 있다. 송신자에게 아무런 영향도 미치지 않고서도 수신자를 교체할 수 있기 때문에 수행 방식을 쉽게 수정 가능하다.
   3. 협력이 수행되는 방식을 재사용할 수 있다.

## 객체 인터페이스

### 인터페이스
   - 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치.

#### 인터페이스 특징
   1. 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
   2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
   3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제없이 상호작용 가능하다.

#### 공용 인터페이스
   - 내부에서만 접근 가능한 사적인 인터페이스와 구분하기 위해 외부에 공개된 인터페이스를 뜻한다.

## 인터페이스와 구현의 분리

### 객체관점에서 생각하는 방법
   1. 너무 구체적인 인터페이스보다 추상적인 인터페이스를 설계하는 것.
   2. 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말라. 인터페이스를 최소로 유지하면 내부 동작에 대해 적은 정보만 노출 시킬 수 있다.
   3. 객체의 외부를 공용 인터페이스라 부르고 내부를 가리키는 용어는 "구현"이라 한다. 이 공용 인터페이스와 구현을 명확하게 분리해라.

### 인터페이스와 구현의 분리 원칙
   - 훌륭한 객체는 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다.
   - 객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속한다. 이것들을 수정해도 외부에 영향을 미쳐서는 안된다.

### 캡슐화
   - 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것은 뜻함.

### 책임의 자율성이 협력의 품질을 결정
   1. 자율적인 책임은 협력을 단순하게 만든다
   2. 자율적인 책임은 객체의 외부와 내부를 명확하게 분리한다
   3. 책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라고 외부에 영향을 미치지 않는다
   4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다
   5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다
      주제 : 자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할, 책임, 협력을 구성하라.

## 6. 객체지도

### 소프트웨어 설계의 두가지 측면
   1. 기능적 접근법 : 소프트웨어가 사용자에게 어떤 기능을 제공하는지에 초점을 맞춤. 초기 개발 단계에서는 사용자 요구에 맞춘 훌륭한 기능을 제공하는 것이 중요하지만 기능만으로는 충분하지 않다.
   2. 구조적 접근법 : 소프트웨어의 형태와 구조를 설계하는 것에 중점을 둔다. 훌륭한 구조는 소프트웨어의 유지보수와 확장성을 용이하게 만들어, 변경되는 요구사항에 유연하게 대응할 수 있도록 한다.
   - 소프트웨어 개발에서 요구사항의 변경은 항상 있다. 설계는 이러한 변경을 수용할 수 있도록 유연성과 확장성을 갖춰야 한다.
   - 객체지향 접근법은 기능보다는 구조를 중심으로 설계하여 변경에 강하고 유연한 소프트웨어를 만들 수 있다.

### 기능과 구조에 일관되게 적용할 두가지 기법 
   1. 기능을 수집하고 표현하기 위한 기법인 유스케이스 모델링
      - 기능적 요구사항은 시스템이 사용자에게 제공해야 하는 기능들의 목록을 의미. 이러한 기능들은 사용자가 시스템을 통해 달성하고자 하는 목표를 중심으로 정의된다.
      - 유스케이스는 기능 목록과 다르다. 단순한 기능 목록은 각각의 기능이 독립적으로 보이게 하지만, 유스케이스는 관련된 기능들은 사용자 목표와 상호작용 흐름 속에서 묶어준다.
      - 사용자 인터페이스나 내부 설계와 관련된 세부 정보를 포함하지 않는다. 자주 변경되는 요소들을 배제.
      - 결과적으로 사용자 목표를 중심으로 시스템의 기능을 정의, 이를 통해 사용자가 시스템과 상호작용하는 과정을 이해하도록 돕는다. 그러나 시스템의 내부 설계와는 직접적
        연관이 없으며 이를 기반으로 객체 구조를 추출하는 것은 창조적이다. 이를통해 객체의 구조를 쉽게 추출할 수 있다는 말에 속지말자.

   2. 구조를 수집하고 표현하기 위한 기법인 도메인 모델링
      - 도메인 모델에서 모델이란 대상을 단순화하고 의식적으로 구조화한 형태. 소프트웨어가 다루는 개념과 규칙을 추상화하여 표현, 이는 사용자와 설계자 시스템 간의 공통된 이해를 돕는다.
      - 사용자가 도메인을 이해하는 방식을 최대한 유사하게 표현해야한다.
      - 안정적인 구조는 도메인 모델을 기반으로 설계되며, 이는 소프트웨어가 기능 변경에 유연하게 대처할 수 있도록 한다. -> 안정성 유지

### 기능과 구조의 통합
   - 도메인 모델과 유스케이스를 결합하여 책임 - 주도 설계를 통해 기능과 구조를 통합하는 것은 유연하고 확장 가능한 소프트웨어를 설계하는 데 필수적이다.
     안정적인 구조와 불안정한 기능을 효과적으로 조화시킴으로써, 소프트웨어가 변경에 유연하게 대응할 수 있게 된다.

## 7. 함께 모으기

### 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점
   1. 개념관점
      - 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현. 사용자가 도메인을 바라보는 관점을 반영. 실제 도메인의 규칙과 제약을 최대한 유사하게 반영.
   2. 명세 관점
      - 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다. 인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙이다.
      - 코드예시
      ```
      # 인터페이스 역할을 하는 클래스
      class Animal:
      def make_sound(self):
      pass
      
      # 구현 1: 개 클래스
      class Dog(Animal):
      def make_sound(self):
      print("Woof!")
      
      # 구현 2: 고양이 클래스
      class Cat(Animal):
      def make_sound(self):
      print("Meow!")
      
      # 클라이언트 코드
      def animal_sound(animal: Animal):
      animal.make_sound()
      
      # 사용 예시
      dog = Dog()
      cat = Cat()
      
      animal_sound(dog)  # "Woof!" 출력
      animal_sound(cat)  # "Meow!" 출력
      ```
      인터페이스와 구현의 분리: Animal 클래스는 인터페이스 역할을 하며, Dog와 Cat 클래스는 구체적인 구현을 제공한다. 이를 통해 animal_sound 함수는 특정 동물에 종속되지 않고,
      다양한 동물 객체를 유연하게 처리할 수 있다.
   3. 구현 관점
      - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것.

   - 하나의 클래스 안에 세가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러내야 훌륭한 객체지향 프로그래머이다.
   - 인터페이스와 구현을 분리해라.
   - 클래스를 봤을때 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다. 캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안되고, 인터페이스와 구현을 명확하게 분리하지 않아도 안된다.

## 부록 - 추상화 기법의 종류

1. 분류와 인스턴스화: 객체의 구체적인 세부사항을 숨기고, 공통의 특성을 기반으로 범주를 형성한다.
2. 일반화와 특수화: 여러 범주 간의 차이를 숨기고, 공통된 특성을 강조. 일반화는 상위 개념을, 특수화는 하위 개념을 정의하는 과정
3. 집합과 분해: 부분과 관련된 세부사항을 숨기고, 부분을 사용하여 전체를 구성하거나, 전체를 부분으로 나누는 과정을 의미.
4. 패키지와 모듈: 패키지나 모듈을 사용해 서로 관련성이 높은 클래스들을 하나의 논리적인 단위로 묶음