> 친절한 SQL 튜닝 참고

# 1. SQL 처리과정과 I/O

# SQL 파싱과 최적화

## SQL 최적화

1. 파싱트리 생성: SQL문을 이루는 개별 요소 분석 후에 트리 생성
2. Syntax 체크: 문법적 오류 체크
3. Semantic 체크: 의미상 오류 체크

2. SQL 최적화

- 옵티마이저가 선택한 경로를 실행 가능한 형태

3. 로우 소스 생성

- 옵티마이저가 선택한 경로를 실행 가능한 형태(프로시저)로 포맷팅

## SQL 옵티마이저

- 옵티마이저가 Decision Tree를 타고 최저 비용을 구한다.

## 실행계획과 비용 - 옵티마이저가 생성한 처리 절차

- 실행경로 변경 가능 -> 옵티마이저 힌트

# SQL 공유 및 재사용

## 소프트파싱 vs 하드파싱

- Library cache: 위의 최적화 과정을 거쳐 생성한 내부 프로시저를 재사용 가능하게 캐싱해둔 곳
- 소프트파싱: 캐시에서 SQL 문을 찾아 곧바로 실행 단계로 넘어가는 것
- 하드파싱: 캐시에서 찾는 것을 실패해서 위 과정을 거치는 것

* SQL은 문자열이고 별도의 이름이 없어 내용으로 식별, 완전히 같아도 각각 최적화를 진행하고 별도 공간 사용
* Prepare statement

- SQL문을 미리 컴파일하여 실행계획을 세우고 실행시점에 값을 바인딩하여 사용하는 방식
  예시) "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?"

- ? 에 값을 채움(추상화와 비슷)

# 데이터 저장 구조 및 I/O 메커니즘

## 데이터베이스 저장 구조

- 블록: 데이터 읽고 쓰는 단위(I/O단위)
- 익스텐트: 공간을 확장하는 단위, 연속된 블록 집합
- 세그먼트: 데이터 저장공간이 필요한 오브젝트(익스텐트 집합)
- 테이블스페이스: 세그먼트를 담는 컨테이너
- 데이터파일: 디스크상의 물리적 OS 파일

## 논리적 I/O vs 물리적 I/O

* 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 튜닝이다.

## Table Full Scan vs Index Range Scan

- 데이터가 소량일 땐 인덱스가 유리, 데이터가 일정량을 넘어가면 Full Scan이 유리

# 2. 인덱스 기본

# 인덱스 구조 및 탐색

- DB테이블에서 데이터를 찾는 방법

1. Full Scan
2. 인덱스를 이용

## 인덱스란?

- <키, ROWID>쌍을 정렬하여 보관하는 데이터 구조. B-Tree 구조로 키값으로 해당 데이터가 저장된 ROWID를 찾는다.
- 인덱스 스캔과 랜덤액세스
  ** SQL 튜닝은 랜덤 I/O와의 전쟁이다 **

## 인덱스 구조

- 수직적 탐색: 인덱스 스캔 시작지점 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정

* 인덱스를 가공하면 정상적으로 스캔 시작점을 찾을 수 없기 때문에 Range Scan이 불가해진다.

### 인덱스를 정상적으로 사용불가한 조건절

- WHERE Substr(생년월일, 5, 2) = '05' // 컬럼값 변환시킴
- WHERE nvl(주문수량, 0) < 100 // 컬럼값 변환시킴
- WHERE 업체명 like '%대한%' // 와일드카드가 앞에 있어서
- WHERE (전화번호 = :tel_no AND 고객명 = cust_nm) // 각 조건에 따라 별도 인덱스 사용
- WHERE 전화번호 in(:tel_no1, :tel_no2) // 전화번호 컬럼 인덱스 여부 따져야 한다. 각 값에 대해 인덱스 수행해야 한다. Full Scan이 효율적일 수도 있다.

## 인덱스를 이용한 sort 연산 생략

- 전체 테이블 스캔 n
- 인덱스 사용 logn
- 인덱스를 사용하면 정렬된 상태 반환. SORT ORDER BY 연산x

## 자동형변환

(약함) 문자형(CHAR, VARCHAR) < 숫자형(INTEGER, DECIMAL) < 날짜/시간형(DATE, TIMESTAMP) (강함)

- 날짜 포맷을 정확히 지정해주어야 한다.

# 인덱스 확장기능 사용법

- 여러 인덱스 스캔 방식

1. Index Range Scan - 가장 일반적 수직 + 수평
2. Index Full Scan - 처음 ~ 끝까지 수평 탐색
3. Index Unique Scan - only 수직탐색, UQ '=' 조건탐색
4. Index Skip Scan - 선두컬럼 개수 적고 후행컬럼은 많을 때 ex)성별이 선두컬럼, 후행컬럼은 연봉
5. Index Fast Scan - 순서(인덱스) 무시하고 쭉 읽는다.

- Multiblock I/O 방식으로 대량의 인덱스 블록 읽을 때 효과 상승, 정렬 x

6. Index Range Scan Descending - 1번을 내림차순

# 3. 인덱스 튜닝

# 테이블 액세스 최소화

## 인덱스 클러스터링 팩터 (CF)

- 클러스터가 얼마나 잘 모여 있나?
- 최후의 방법(수동)

## 인덱스 손익분기점

- CF 효과 p137 참고(CF에 따른 블록 I/O 발생량의 차이)

## OLTP 환경에서 부분범위 처리에 의한 성능개선

- OLTP(Online Transaction Processing): 소량, realtime
- OLAP(Online Analysis Process): 대량, batch

## 인덱스 구조 테이블

- IOT(Index Organized Table)
- 랜덤액세스 발생 x
- 극단적, 테이블 두개 합치기

# 인덱스 스캔 효율화

- 운영환경에서 가능한 일반적인 튜닝기법은 인덱스 컬럼 추가

## 인덱스 탐색

- Range가 좁을수록 빠르다.
- 등치면 한번에 간다.(제일 빠름)
- 첫 번째 조건이 넓으면 뒤에서 좁히기 어렵다.

** 중간에 조건절이 빠지면 뒤의 조건들은 없는 것이나 마찬가지 **

## 액세스 조건과 필터조건 - 인덱스 스캔 효율성 필수 개념

## 순서에 따른 군집성

- 등치조건을 앞쪽에
- 넓은 범위를 앞쪽에 두면 그 뒤로는 제 역할 못한다.

## BETWEEN을 IN-LIST로 전환

- 운영시스템에서 인덱스 구성의 변경이 불가할 때
- 옵티마이저가 범위를 등치로 바꾼다.
- 쿼리가 3개지만 느린 1개보다 빠를 수 있다.
- 데이터가 너무 많을 때는 사용x
- 레코드가 서로 멀리 떨어져 있을 때 유용

## BETWEEN과 LIKE 스캔 범위 비교

- BETWEEN을 사용하는 게 더 낫다.
- 데이터 분포와 조건절 값에 따라 인덱스 스캔량 차이 있다.

## 함수호출부하 해소를 위한 인덱스 구성

- java 함수 쓰면 성능 떨어진다. ex)encryption()

### PL/SQL 사용자 정의함수가 느린 이유

1. 가상머신상에서 실행되는 인터프리터 언어
2. 호출 시마다 문맥교환 발생
3. 내장 SQL에 대한 RECURSIVE CALL 발생

# 인덱스 설계

## 인덱스 설계가 어려운 이유

### 인덱스가 많을 때의 문제점

- DML성능 저하
- DB 사이즈 증가
- DB 관리 및 운영 비용 상승

