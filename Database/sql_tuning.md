> 친절한 SQL 튜닝 참고

1. SQL 처리과정과 I/O

# SQL 파싱과 최적화

## SQL 최적화

1. 파싱트리 생성: SQL문을 이루는 개별 요소 분석 후에 트리 생성
2. Syntax 체크: 문법적 오류 체크
3. Semantic 체크: 의미상 오류 체크

2. SQL 최적화

- 옵티마이저가 선택한 경로를 실행 가능한 형태

3. 로우 소스 생성

- 옵티마이저가 선택한 경로를 실행 가능한 형태(프로시저)로 포맷팅

## SQL 옵티마이저

- 옵티마이저가 Decision Tree를 타고 최저 비용을 구한다.

## 실행계획과 비용 - 옵티마이저가 생성한 처리 절차

- 실행경로 변경 가능 -> 옵티마이저 힌트

# SQL 공유 및 재사용

## 소프트파싱 vs 하드파싱

- Library cache: 위의 최적화 과정을 거쳐 생성한 내부 프로시저를 재사용 가능하게 캐싱해둔 곳
- 소프트파싱: 캐시에서 SQL 문을 찾아 곧바로 실행 단계로 넘어가는 것
- 하드파싱: 캐시에서 찾는 것을 실패해서 위 과정을 거치는 것

* SQL은 문자열이고 별도의 이름이 없어 내용으로 식별, 완전히 같아도 각각 최적화를 진행하고 별도 공간 사용
* Prepare statement

- SQL문을 미리 컴파일하여 실행계획을 세우고 실행시점에 값을 바인딩하여 사용하는 방식
  예시) "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?"

- ? 에 값을 채움(추상화와 비슷)

# 데이터 저장 구조 및 I/O 메커니즘

## 데이터베이스 저장 구조

- 블록: 데이터 읽고 쓰는 단위(I/O단위)
- 익스텐트: 공간을 확장하는 단위, 연속된 블록 집합
- 세그먼트: 데이터 저장공간이 필요한 오브젝트(익스텐트 집합)
- 테이블스페이스: 세그먼트를 담는 컨테이너
- 데이터파일: 디스크상의 물리적 OS 파일

## 논리적 I/O vs 물리적 I/O

* 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 튜닝이다.

## Table Full Scan vs Index Range Scan

- 데이터가 소량일 땐 인덱스가 유리, 데이터가 일정량을 넘어가면 Full Scan이 유리