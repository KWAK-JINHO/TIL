[//]: # (Redis 정리)

[//]: # (정리자료: 유튜브 [NHN FORWARD 2021] Redis 야무지게 사용하기)

## 👉 캐시(Cache)란?

데이터의 원래 소스보다 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소

## 사용하는 이유

사용자의 요청마다 매번 DB에 ~ 하기에는 비효율적인 데이터들이 있음 예를들면 자주 변하지 않는 카테고리 명 등, 그럴때 미리 데이터를 워밍 해놓은 인메모리 DB를
사용하는것이 효율적이기 때문

## Redis 란?

- 단순한 key-value로 구조
- 인메모리 데이터 저장소(RAM)으로, 평균 읽기 및 쓰기 속도가 1밀리세컨드 미만으로 초당 수백만건의 작업 가능, 지연율이 줄어들고 처리량이 늘어난다.

## Redis를 주로 사용하는 경우

- 세션 스토어: 사용자 로그인 정보, 장바구니 데이터 저장 등 여러 서버 간 세션 공유 필요시
- 실시간 랭킹: Sorted Set을 활용한 실시간 순위 처리
- 분산 락: Redisson을 활용한 분산 락(Java의 경우)
- 메시징: pub/sub 메시지 큐

## 꼭 Redis를 사용해야 하는가?

대안으로는 Caffeine을 사용할 수 있다.

Caffeine이란?

- 애플리케이션과 같은 JVM 내 Heap 공간을 사용한다.
- 빠르지만 분산환경에서의 공유가 불가하다.

---

# 캐싱전략

레디스를 사용할 때 어떻게 배치하는지에 따라서도 시스템에 영향을 미친다. 이를 캐싱 전략이라고도 하며, 데이터의 유형, 액세스 패턴을 고려해 캐싱전략을 수립해야한다.

## 읽기 전략 (Look-Aside/Cache-Aside)

레디스를 사용할때 가장 일반적인 구조

### 동작 과정

1. 애플리케이션이 데이터를 조회할 때 캐시를 먼저 조회
2. 찾는 데이터가 없다면 DB를 조회하고 캐시에 저장
3. 찾는 데이터가 없을 때만 DB를 조회 (Lazy Loading)

### 특징

- Redis가 다운되어도 DB 서버는 살아있기 때문에 장애가 터지지는 않음
- 하지만 DB에 갑자기 많은 커넥션이 몰려 부하가 생길 수 있음
- 캐시를 새로 투입하거나 DB에만 새로운 데이터를 저장한 경우 처음에 캐시미스가 엄청 많이 생길 수 있다. 이럴 때는 DB에서 미리 캐시에 데이터를 밀어넣어주는
  'Cache Warming' 을 해주어야 함

## 쓰기 전략 1 (Write-Around)

DB에만 데이터를 저장하는 구조

## 특징

- 일단 모든 데이터를 DB에 저장
- 캐시미스가 발생한 경우 캐시의 데이터를 끌어옴
- 이 경우는 캐시 내의 데이터와 DB 내의 데이터가 다를 수 있음

## 쓰기 전략 2 (Write-Through)

캐시에 먼저 저장하고 후에 DB에도 저장하는 구조

### 특징

- 저장할 때마다 두단계 스탭 을 거친다. -> 상대적으로 느리다.
- 재사용되지 않는 데이터도 저장하여 리소스를 낭비한다. -> 데이터를 만료시간을 설정하는게 좋다. 하지만 이 값을 어떻게 관리하는지에 따라 장애 포인트가 될 수 있다.

---

# Redis 데이터 타입

## 기본 데이터 타입 (Key)

- String: 제일 기본적인 타입으로 SET command로 저장한 데이터는 모두 String으로 저장된다.
- Bitmaps: bit 단위의 연산 가능
- Lists: 큐로 사용
- Hashes: Key 안에 또다른 Key와 Value의 쌍을 저장한다.
- Sets: 중복되지 않은 문자열의 집합
- Sorted Sets: 중복되지 않는 Sets 처럼 중복되지 않는 값이지만 모든 값은 Score라는 값으로 저장된다. 데이터가 저장될때부터 Score순으로 정렬되며 Score가 같다면 사전순으로 정렬
- HyperLogLogs: 많은 데이터를 다룰때 사용 중복되지 않은 값의 개수를 카운트할 때 사용
- Streams: Log를 저장할 때 사용

## Best Practice 활용 사례

## 증감연산

- 키 하나를 만들어서 카운팅할 상황마다 하나씩 증가
- INCR 함수 사용

## Bit연산

- 한 개의 비트는 한 명으로 표현이 가능
- SETBIT로 설정 후 BITCOUNT로 증가
- 하지만 정수값일 때만 사용가능 (sequential한 값이 있어야 사용가능)

## HyperLogLogs

- 모든 String 데이터를 유니크하게 관리할 수 있음
- SET과 비슷하지만 대량의 데이터를 카운팅할 때 적합
- 저장되는 데이터의 용량이 12KB로 고정
- 한번 저장된 데이터는 다시 확인할 수 없음
- PFADD로 저장, PFCOUNT로 조회, PFMERGE로 합쳐서 조회 가능

## Messaging (Lists)

- Lists는 메시지큐로 적절
- 자체적인 Blocking을 잘 이용하면 불필요한 polling process를 막을 수 있음
- LPUSHX/RPUSHX 사용해 키가 있을 때만 List에 데이터를 추가 (예전에 사용했던 큐에만 메시지를 넣어줄 수 있음)

## 소셜 미디어 타임라인

- 각 유저별로 타임라인 존재 (트위터, 인스타)
- 해당 타임라인에 내가 팔로우한 사람의 데이터가 노출
- 트위터는 팔로우한 사람들에게 보여줄 데이터를 캐싱하기 위해서 RPUSHX 커맨드를 사용해 트위터를 자주 이용하던 유저에게만 캐시를 하고 아니면 캐싱키 자체를 만들지 않아 비효율적인 데이터 적재를 방지

## Streams

- 로그를 저장하기 가장 적절한 자료구조로 append-only 방식으로 저장
- XADD로 해당 키의 데이터를 저장, id값을 *로 세팅하면 알아서 들어감
- Kafka를 많이 따라함. Redis 공식문서에서도 간단한 메시징 큐 구현을 할 때 Kafka를 대체해서 사용할 수 있다고 소개한다.

---

# Redis Persistence (RDB vs AOF)

Redis는 in-memory 데이터 스토어로 서버 재시작 시 모든 데이터가 유실된다. 복제 구조를 사용하고 있더라도 코드상의 버그가 있었거나 사람의 실수로 데이터를
날렸으면 바로 복제본에도 똑같이 적용되어 복원이 어렵다. 때문에 캐시 이외의 용도로 사용하려면 별도의 설정이 필요하다.

## Redis Persistence 옵션

1. AOF (Append Only File)

커맨드가 들어오면 그대로 저장

- 파일이 계속 커지기 때문에 주기적으로 파일을 압축해 재작성하는 과정을 거쳐야 함
- 데이터 손실 최소화
- 파일 크고 복구 오래 걸림

2. RDB (Redis Database)

스냅샷을 찍어 저장

- 시간을 기준으로 파일 저장이 가능 (디스크에 바이너리 형태로 저장)
- 스냅샷 방식
- 압축률이 높음
- 복구 속도는 빠르지만 스냅샷 이후 데이터가 손실 가능성이 있음

## 사용 시나리오별 권장사항

Redis를 캐시로만 사용할 때는 위 두 가지 옵션을 이용할 필요가 없다.

1. 어느 정도 데이터 손실을 감수할 수 있는 상황

- RDB 단독 사용
- Redis.conf 파일에서 SAVE 옵션을 적절히 사용

2. 장애 상황 직전까지의 모든 데이터가 보장되어야 할 경우

- AOF 사용 (append only yes)
- AppendFSYNC 옵션이 everysec인 경우 최대 1초 사이의 데이터 유실 가능 (기본 설정)

3. 제일 강력한 내구성이 필요한 경우

두 가지 모두 사용

---

# 아키텍쳐 선택 가이드

1. Replication (복제)

Master-Slave 구조로 데이터 복사

## 특징

- Master에서 쓰기, Slave에서 읽기 분산 가능
- 단순한 백업 + 읽기 성능 향상 목적
- 모든 복제는 비동기식으로 작동
- replicaof 커맨드를 이용해 간단하게 복제 연결

## 단점

- Master 장애 시 수동으로 Slave를 Master로 승격해야 함
- HA 기능이 없으므로 장애상황 시 수동 복구
- replicaof no one
- 애플리케이션에서 연결 정보 변경하는 작업이 필요

2. Sentinel

Replication + Sentinel 프로세스 (자동 장애복구 기능) 추가

## 특징

- 센티널 노드는 항상 3대 이상의 홀수로 존재
- 과반수 이상의 sentinel이 동의해야 페일오버를 진행
- Sentinel이 Master/Slave 상태를 모니터링
- Master 장애 시 자동으로 Slave를 Master로 승격
- 고가용성(HA) 제공하지만 여전히 단일 Master 구조
- 애플리케이션에서는 센티널 노드만 알고 있으면 됨

3. Cluster

다중 Master 구조로 데이터를 샤딩

## 특징

- 최소 3대 마스터 필요
- 각 Master마다 Slave를 두어 고가용성도 제공 (일반적인 구조)
- 수평 확장 가능 (노드 추가로 용량/성능 증대)

# 아키텍처 선택 기준

선택 플로우:

1. HA(고가용성)가 필요한가?

- 필요없음 → 복제가 필요한지 확인 → Standalone or Replication
- 필요함 → 2번으로

2. 스케일 아웃이 필요한가?

- 필요없음 → Sentinel
- 필요함 → Cluster

📌 참고: HA(고가용성)
'가용성은 시스템이 정상적으로 사용 가능한 시간의 비율'이다. 따라서 고가용성은 서비스 중단 시간을 최소화하기 위한 것이다.
Redis 장애 → 캐시 미스 → DB 과부하 순서로 서비스 장애에 직결된다.

---

# 장애 포인트

Redis는 싱글 스레드이다.
때문에 한 사용자가 오래 걸리는 커맨드를 사용한다면 뒤 요청이 모두 대기한다. 때문에 커맨드 사용에 매우 주의해야 한다.

주의해야 할 커맨드:

keys: 모든 키를 보여주는 커맨드인데 운영환경에서 실수로 사용하면 안됨 → scan으로 대체하여 사용
Hash, Sorted Set: 키 내부의 아이템이 많아질수록 성능 저하의 요인. 하나의 키에 백만 개 이상 저장하지 않는 걸 권장
delete: 키에 많은 데이터가 들어 있을 때 delete를 사용하면 안됨 → unlink를 사용하여 키를 백그라운드로 지워주기 때문에 이를 사용

## 기본 설정값 최적화

### STOP-WRITES-ON-BGSAVE-ERROR = NO

- 기본값이 yes → RDB파일이 정상적으로 저장되지 않았을 때 redis로 들어오는 모든 기능을 차단
- Redis를 모니터링하고 있다면 이 설정을 꺼두는 게 장애를 막음

### MAXMEMORY-POLICY = ALLKEYS-LRU

Redis를 캐시로 사용할 때 Expire Time 설정 권장. 메모리 가득 차면 키 삭제됨.

#### 옵션들

- noeviction (기본값): 삭제 안함 → 레디스가 가득 차면 더 이상 새로운 데이터 받지 않음
- volatile-lru: 제일 오래 사용 안 된 것부터 삭제 (expire 설정되어 있는 것만, 만약 expire 설정이 없는 것만 남았다면 위와 같은 장애 발생 가능)
- allkeys-lru: 모든 키에 대해 lru 방식으로 관리하겠다는 설정

### 캐시 스탬피드 (Cache Stampede) 주의

대규모 트래픽 환경에서 TTL값을 너무 작게 설정할 경우 캐시 스탬피드 발생 가능성 있음.

#### 발생 상황

1. Look-aside 전략을 사용했을 때, 서버가 직접 DB로 요청 후 레디스에 다시 저장하려 할 텐데
2. 만약 여러 서버에서 이 key를 같이 보고 있었다면 모든 애플리케이션 서버들이 DB에 가서 같이 해당 key를 찾으려 함
3. 동시에 레디스에 동시에 작성하려고 할 것임

해결책: TTL을 넉넉하게 늘려 해결 등

---

# MaxMemory 값 설정

## 메모리 2배 사용 원리

Redis가 데이터를 디스크에 저장할 때 fork()를 통해 자식 프로세스를 생성

### 동작 과정

- 이는 백그라운드에서 실행 (자식 프로세스가 RDB/AOF 파일 생성)
- 원래(부모) 프로세스는 일반적인 요청을 받아 데이터를 처리하고 있음

### Copy-on-Write 메커니즘

- 초기에는 부모와 자식이 같은 메모리 공간 공유
- 데이터 변경 시에만 메모리 복사 발생
- 최악의 경우 메모리 사용량이 2배까지 증가 가능

### 위험 상황

복제 연결을 처음 시도 또는 재시도할 때 새로 RDB 파일을 저장하는 과정을 거치기 때문에 조심해야 함.

### 권장 설정

persistence / 복제 사용 시 MaxMemory는 실제 메모리의 절반으로 설정
예상하지 못하는 때에 메모리가 풀이 가득 차서 장애 발생할 수 있음.

---

# 메모리 관리

## 모니터링 지표

모니터링할 때 used_memory_rss (OS가 Redis에 할당하기 위해 사용한 물리적 메모리 양)를 used_memory (논리적으로 Redis가 사용하는 메모리)보다 주의해서 봐야 함.

## 메모리 단편화 (Fragmentation)

실제 저장된 양은 적은데 삭제되는 키가 많으면 fragmentation이 증가함.

## 발생 상황

- 특정 시점에 피크를 찍고 다시 삭제되는 경우
- TTL로 인한 eviction이 많이 발생한 경우

해결책: 잠시동안 activedefrag yes 설정을 켜서 단편화를 해결하고 끄자